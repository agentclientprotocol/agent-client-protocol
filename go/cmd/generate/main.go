package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	//nolint // We intentionally use dot-import for Jennifer codegen readability
	. "github.com/dave/jennifer/jen"
)

type Meta struct {
	Version       int               `json:"version"`
	AgentMethods  map[string]string `json:"agentMethods"`
	ClientMethods map[string]string `json:"clientMethods"`
}

type Schema struct {
	Defs map[string]*Definition `json:"$defs"`
}

type Definition struct {
	Description string                 `json:"description"`
	Type        any                    `json:"type"`
	Properties  map[string]*Definition `json:"properties"`
	Required    []string               `json:"required"`
	Enum        []any                  `json:"enum"`
	Items       *Definition            `json:"items"`
	Ref         string                 `json:"$ref"`
	AnyOf       []*Definition          `json:"anyOf"`
	OneOf       []*Definition          `json:"oneOf"`
	DocsIgnore  bool                   `json:"x-docs-ignore"`
	Title       string                 `json:"title"`
	Const       any                    `json:"const"`
	XSide       string                 `json:"x-side"`
	XMethod     string                 `json:"x-method"`
}

// methodInfo captures the association between a wire method and its Go types.
type methodInfo struct{ Side, Method, Req, Resp, Notif string }

func main() {
	repoRoot := findRepoRoot()
	schemaDir := filepath.Join(repoRoot, "schema")
	outDir := filepath.Join(repoRoot, "go")

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		panic(err)
	}

	// Read meta.json
	metaBytes, err := os.ReadFile(filepath.Join(schemaDir, "meta.json"))
	if err != nil {
		panic(fmt.Errorf("read meta.json: %w", err))
	}
	var meta Meta
	if err := json.Unmarshal(metaBytes, &meta); err != nil {
		panic(fmt.Errorf("parse meta.json: %w", err))
	}

	// Write constants.go
	if err := writeConstantsJen(outDir, &meta); err != nil {
		panic(err)
	}

	// Read schema.json
	schemaBytes, err := os.ReadFile(filepath.Join(schemaDir, "schema.json"))
	if err != nil {
		panic(fmt.Errorf("read schema.json: %w", err))
	}
	var schema Schema
	if err := json.Unmarshal(schemaBytes, &schema); err != nil {
		panic(fmt.Errorf("parse schema.json: %w", err))
	}

	if err := writeTypesJen(outDir, &schema, &meta); err != nil {
		panic(err)
	}

	if err := writeDispatchJen(outDir, &schema, &meta); err != nil {
		panic(err)
	}
}

func findRepoRoot() string {
	// Assume this generator runs from repo root or subfolders; walk up to find package.json
	cwd, _ := os.Getwd()
	dir := cwd
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "package.json")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return cwd
}

func writeConstantsJen(outDir string, meta *Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")
	f.Comment("ProtocolVersionNumber is the ACP protocol version supported by this SDK.")
	f.Const().Id("ProtocolVersionNumber").Op("=").Lit(meta.Version)

	// Agent methods (deterministic order)
	amKeys := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys = append(amKeys, k)
	}
	sort.Strings(amKeys)
	var agentDefs []Code
	for _, k := range amKeys {
		wire := meta.AgentMethods[k]
		agentDefs = append(agentDefs, Id("AgentMethod"+toExportedConst(k)).Op("=").Lit(wire))
	}
	f.Comment("Agent method names")
	f.Const().Defs(agentDefs...)

	// Client methods (deterministic order)
	cmKeys := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys = append(cmKeys, k)
	}
	sort.Strings(cmKeys)
	var clientDefs []Code
	for _, k := range cmKeys {
		wire := meta.ClientMethods[k]
		clientDefs = append(clientDefs, Id("ClientMethod"+toExportedConst(k)).Op("=").Lit(wire))
	}
	f.Comment("Client method names")
	f.Const().Defs(clientDefs...)

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "constants.go"), buf.Bytes(), 0o644)
}

func toExportedConst(s string) string {
	// Convert snake_case like session_new to SessionNew
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = titleWord(parts[i])
	}
	return strings.Join(parts, "")
}

func writeTypesJen(outDir string, schema *Schema, meta *Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	// Deterministic order
	keys := make([]string, 0, len(schema.Defs))
	for k := range schema.Defs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, name := range keys {
		def := schema.Defs[name]
		if def == nil {
			continue
		}

		// Type-level comment
		if def.Description != "" {
			f.Comment(sanitizeComment(def.Description))
		}

		switch {
		case len(def.Enum) > 0:
			// string enum
			f.Type().Id(name).String()
			// const block
			defs := []Code{}
			for _, v := range def.Enum {
				s := fmt.Sprint(v)
				defs = append(defs, Id(toEnumConst(name, s)).Id(name).Op("=").Lit(s))
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case isStringConstUnion(def):
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.OneOf {
				if v != nil && v.Const != nil {
					s := fmt.Sprint(v.Const)
					defs = append(defs, Id(toEnumConst(name, s)).Id(name).Op("=").Lit(s))
				}
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case name == "ContentBlock":
			emitContentBlockJen(f)
		case name == "ToolCallContent":
			emitToolCallContentJen(f)
		case name == "EmbeddedResourceResource":
			emitEmbeddedResourceResourceJen(f)
		case name == "RequestPermissionOutcome":
			emitRequestPermissionOutcomeJen(f)
		case name == "SessionUpdate":
			emitSessionUpdateJen(f)
		case primaryType(def) == "object" && len(def.Properties) > 0:
			// Build struct fields
			st := []Code{}
			// required lookup
			req := map[string]struct{}{}
			for _, r := range def.Required {
				req[r] = struct{}{}
			}
			// sorted properties
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, pk := range pkeys {
				prop := def.Properties[pk]
				field := toExportedField(pk)
				// field comment must directly precede field without blank line
				if prop.Description != "" {
					st = append(st, Comment(sanitizeComment(prop.Description)))
				}
				tag := pk
				if _, ok := req[pk]; !ok {
					tag = pk + ",omitempty"
				}
				st = append(st, Id(field).Add(jenTypeForOptional(prop)).Tag(map[string]string{"json": tag}))
			}
			f.Type().Id(name).Struct(st...)
			f.Line()
		case primaryType(def) == "string" || primaryType(def) == "integer" || primaryType(def) == "number" || primaryType(def) == "boolean":
			f.Type().Id(name).Add(primitiveJenType(primaryType(def)))
			f.Line()
		default:
			// unions etc.
			f.Comment(fmt.Sprintf("%s is a union or complex schema; represented generically.", name))
			f.Type().Id(name).Any()
			f.Line()
		}

		// Emit basic validators for RPC/union types
		if strings.HasSuffix(name, "Request") || strings.HasSuffix(name, "Response") || strings.HasSuffix(name, "Notification") || name == "ContentBlock" || name == "ToolCallContent" || name == "SessionUpdate" || name == "ToolCallUpdate" {
			emitValidateJen(f, name, def)
		}
	}

	// Append Agent and Client interfaces derived from meta.json + schema defs
	{
		groups := buildMethodGroups(schema, meta)

		// Helper: determine if a method is undocumented (x-docs-ignore)
		isDocsIgnored := func(mi *methodInfo) bool {
			if mi == nil {
				return false
			}
			if mi.Req != "" {
				if d := schema.Defs[mi.Req]; d != nil && d.DocsIgnore {
					return true
				}
			}
			if mi.Resp != "" {
				if d := schema.Defs[mi.Resp]; d != nil && d.DocsIgnore {
					return true
				}
			}
			if mi.Notif != "" {
				if d := schema.Defs[mi.Notif]; d != nil && d.DocsIgnore {
					return true
				}
			}
			return false
		}

		// Agent
		agentMethods := []Code{}
		// Optional loader methods live on a separate interface
		agentLoaderMethods := []Code{}
		// Undocumented/experimental methods live on a separate interface
		agentExperimentalMethods := []Code{}
		amKeys := make([]string, 0, len(meta.AgentMethods))
		for k := range meta.AgentMethods {
			amKeys = append(amKeys, k)
		}
		sort.Strings(amKeys)
		for _, k := range amKeys {
			wire := meta.AgentMethods[k]
			mi := groups["agent|"+wire]
			if mi == nil {
				continue
			}
			// Treat session/load as optional (AgentLoader)
			target := &agentMethods
			if wire == "session/load" {
				target = &agentLoaderMethods
			}
			// Undocumented/experimental agent methods go to AgentExperimental
			if isDocsIgnored(mi) {
				target = &agentExperimentalMethods
			}
			if mi.Notif != "" {
				name := dispatchMethodNameForNotification(k, mi.Notif)
				*target = append(*target, Id(name).Params(Id("params").Id(mi.Notif)).Error())
			} else if mi.Req != "" {
				respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
				methodName := strings.TrimSuffix(mi.Req, "Request")
				if isNullResponse(schema.Defs[respName]) {
					*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Error())
				} else {
					*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()))
				}
			}
		}
		// Emit interfaces
		f.Type().Id("Agent").Interface(agentMethods...)
		if len(agentLoaderMethods) > 0 {
			f.Comment("AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.")
			f.Type().Id("AgentLoader").Interface(agentLoaderMethods...)
		}
		if len(agentExperimentalMethods) > 0 {
			f.Comment("AgentExperimental defines undocumented/experimental methods (x-docs-ignore). These may change or be removed without notice.")
			f.Type().Id("AgentExperimental").Interface(agentExperimentalMethods...)
		}

		// Client
		clientStable := []Code{}
		clientExperimental := []Code{}
		cmKeys := make([]string, 0, len(meta.ClientMethods))
		for k := range meta.ClientMethods {
			cmKeys = append(cmKeys, k)
		}
		sort.Strings(cmKeys)
		for _, k := range cmKeys {
			wire := meta.ClientMethods[k]
			mi := groups["client|"+wire]
			if mi == nil {
				continue
			}
			target := &clientStable
			if isDocsIgnored(mi) {
				target = &clientExperimental
			}
			if mi.Notif != "" {
				name := dispatchMethodNameForNotification(k, mi.Notif)
				*target = append(*target, Id(name).Params(Id("params").Id(mi.Notif)).Error())
			} else if mi.Req != "" {
				respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
				methodName := strings.TrimSuffix(mi.Req, "Request")
				if isNullResponse(schema.Defs[respName]) {
					*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Error())
				} else {
					*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()))
				}
			}
		}
		f.Type().Id("Client").Interface(clientStable...)
		if len(clientExperimental) > 0 {
			f.Comment("ClientExperimental defines undocumented/experimental methods (x-docs-ignore), such as terminal support. Implement and advertise the related capability to enable them.")
			f.Type().Id("ClientExperimental").Interface(clientExperimental...)
		}
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "types.go"), buf.Bytes(), 0o644)
}

func isStringConstUnion(def *Definition) bool {
	if def == nil || len(def.OneOf) == 0 {
		return false
	}
	for _, v := range def.OneOf {
		if v == nil || v.Const == nil {
			return false
		}
		if _, ok := v.Const.(string); !ok {
			return false
		}
	}
	return true
}

// isDocsIgnoredMethod returns true if any of the method's associated types
// (request, response, notification) are marked with x-docs-ignore in the schema.
func isDocsIgnoredMethod(schema *Schema, mi *methodInfo) bool {
	if mi == nil {
		return false
	}
	if mi.Req != "" {
		if d := schema.Defs[mi.Req]; d != nil && d.DocsIgnore {
			return true
		}
	}
	if mi.Resp != "" {
		if d := schema.Defs[mi.Resp]; d != nil && d.DocsIgnore {
			return true
		}
	}
	if mi.Notif != "" {
		if d := schema.Defs[mi.Notif]; d != nil && d.DocsIgnore {
			return true
		}
	}
	return false
}

// emitValidateJen generates a simple Validate method for selected types.
func emitValidateJen(f *File, name string, def *Definition) {
	switch name {
	case "ContentBlock":
		f.Func().Params(Id("c").Op("*").Id("ContentBlock")).Id("Validate").Params().Params(Error()).Block(
			Switch(Id("c").Dot("Type")).Block(
				Case(Lit("text")).Block(If(Id("c").Dot("Text").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.text missing"))))),
				Case(Lit("image")).Block(If(Id("c").Dot("Image").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.image missing"))))),
				Case(Lit("audio")).Block(If(Id("c").Dot("Audio").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.audio missing"))))),
				Case(Lit("resource_link")).Block(If(Id("c").Dot("ResourceLink").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.resource_link missing"))))),
				Case(Lit("resource")).Block(If(Id("c").Dot("Resource").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.resource missing"))))),
			),
			Return(Nil()),
		)
		return
	case "ToolCallContent":
		f.Func().Params(Id("t").Op("*").Id("ToolCallContent")).Id("Validate").Params().Params(Error()).Block(
			Switch(Id("t").Dot("Type")).Block(
				Case(Lit("content")).Block(If(Id("t").Dot("Content").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolcallcontent.content missing"))))),
				Case(Lit("diff")).Block(If(Id("t").Dot("Diff").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolcallcontent.diff missing"))))),
				Case(Lit("terminal")).Block(If(Id("t").Dot("Terminal").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolcallcontent.terminal missing"))))),
			),
			Return(Nil()),
		)
		return
	case "SessionUpdate":
		f.Func().Params(Id("s").Op("*").Id("SessionUpdate")).Id("Validate").Params().Params(Error()).Block(
			Var().Id("count").Int(),
			If(Id("s").Dot("UserMessageChunk").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("AgentMessageChunk").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("AgentThoughtChunk").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("ToolCall").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("ToolCallUpdate").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("Plan").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("count").Op("!=").Lit(1)).Block(Return(Qual("fmt", "Errorf").Call(Lit("sessionupdate must have exactly one variant set")))),
			Return(Nil()),
		)
		return
	case "ToolCallUpdate":
		f.Func().Params(Id("t").Op("*").Id("ToolCallUpdate")).Id("Validate").Params().Params(Error()).Block(
			If(Id("t").Dot("ToolCallId").Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolCallId is required")))),
			Return(Nil()),
		)
		return
	}
	// Generic RPC objects
	if def != nil && primaryType(def) == "object" {
		if !(strings.HasSuffix(name, "Request") || strings.HasSuffix(name, "Response") || strings.HasSuffix(name, "Notification")) {
			return
		}
		f.Func().Params(Id("v").Op("*").Id(name)).Id("Validate").Params().Params(Error()).BlockFunc(func(g *Group) {
			// Emit checks in deterministic property order
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, propName := range pkeys {
				pDef := def.Properties[propName]
				// is required?
				required := false
				for _, r := range def.Required {
					if r == propName {
						required = true
						break
					}
				}
				field := toExportedField(propName)
				if required {
					switch primaryType(pDef) {
					case "string":
						g.If(Id("v").Dot(field).Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					case "array":
						g.If(Id("v").Dot(field).Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					}
				}
			}
			g.Return(Nil())
		})
	}
}

// buildMethodGroups merges schema-provided links with inferred ones from meta.
func buildMethodGroups(schema *Schema, meta *Meta) map[string]*methodInfo {
	groups := map[string]*methodInfo{}
	// From schema
	for name, def := range schema.Defs {
		if def == nil || def.XMethod == "" || def.XSide == "" {
			continue
		}
		key := def.XSide + "|" + def.XMethod
		mi := groups[key]
		if mi == nil {
			mi = &methodInfo{Side: def.XSide, Method: def.XMethod}
			groups[key] = mi
		}
		if strings.HasSuffix(name, "Request") {
			mi.Req = name
		}
		if strings.HasSuffix(name, "Response") {
			mi.Resp = name
		}
		if strings.HasSuffix(name, "Notification") {
			mi.Notif = name
		}
	}
	// From meta fallback (e.g., terminal methods)
	for key, wire := range meta.AgentMethods {
		k := "agent|" + wire
		if groups[k] == nil {
			base := inferTypeBaseFromMethodKey(key)
			mi := &methodInfo{Side: "agent", Method: wire}
			if wire == "session/cancel" {
				mi.Notif = "CancelNotification"
			} else {
				if _, ok := schema.Defs[base+"Request"]; ok {
					mi.Req = base + "Request"
				}
				if _, ok := schema.Defs[base+"Response"]; ok {
					mi.Resp = base + "Response"
				}
			}
			if mi.Req != "" || mi.Notif != "" {
				groups[k] = mi
			}
		}
	}
	for key, wire := range meta.ClientMethods {
		k := "client|" + wire
		if groups[k] == nil {
			base := inferTypeBaseFromMethodKey(key)
			mi := &methodInfo{Side: "client", Method: wire}
			if wire == "session/update" {
				mi.Notif = "SessionNotification"
			} else {
				if _, ok := schema.Defs[base+"Request"]; ok {
					mi.Req = base + "Request"
				}
				if _, ok := schema.Defs[base+"Response"]; ok {
					mi.Resp = base + "Response"
				}
			}
			if mi.Req != "" || mi.Notif != "" {
				groups[k] = mi
			}
		}
	}
	return groups
}

func inferTypeBaseFromMethodKey(methodKey string) string {
	// Special-case known irregular mappings
	if methodKey == "terminal_wait_for_exit" {
		return "WaitForTerminalExit"
	}
	parts := strings.Split(methodKey, "_")
	if len(parts) == 2 {
		n, v := parts[0], parts[1]
		switch v {
		case "new", "create", "release", "wait", "load", "authenticate", "prompt", "cancel", "read", "write":
			return titleWord(v) + titleWord(n)
		default:
			return titleWord(n) + titleWord(v)
		}
	}
	segs := strings.Split(methodKey, "_")
	for i := range segs {
		segs[i] = titleWord(segs[i])
	}
	return strings.Join(segs, "")
}

func emitContentBlockJen(f *File) {
	// ResourceLinkContent helper
	f.Type().Id("ResourceLinkContent").Struct(
		Id("Annotations").Any().Tag(map[string]string{"json": "annotations,omitempty"}),
		Id("Description").Op("*").String().Tag(map[string]string{"json": "description,omitempty"}),
		Id("MimeType").Op("*").String().Tag(map[string]string{"json": "mimeType,omitempty"}),
		Id("Name").String().Tag(map[string]string{"json": "name"}),
		Id("Size").Op("*").Int64().Tag(map[string]string{"json": "size,omitempty"}),
		Id("Title").Op("*").String().Tag(map[string]string{"json": "title,omitempty"}),
		Id("Uri").String().Tag(map[string]string{"json": "uri"}),
	)
	f.Line()
	// ContentBlock
	f.Type().Id("ContentBlock").Struct(
		Id("Type").String().Tag(map[string]string{"json": "type"}),
		Id("Text").Op("*").Id("TextContent").Tag(map[string]string{"json": "-"}),
		Id("Image").Op("*").Id("ImageContent").Tag(map[string]string{"json": "-"}),
		Id("Audio").Op("*").Id("AudioContent").Tag(map[string]string{"json": "-"}),
		Id("ResourceLink").Op("*").Id("ResourceLinkContent").Tag(map[string]string{"json": "-"}),
		Id("Resource").Op("*").Id("EmbeddedResource").Tag(map[string]string{"json": "-"}),
	)
	f.Line()
	// UnmarshalJSON for ContentBlock
	f.Func().Params(Id("c").Op("*").Id("ContentBlock")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("probe").Struct(Id("Type").String().Tag(map[string]string{"json": "type"})),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("probe")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Id("c").Dot("Type").Op("=").Id("probe").Dot("Type"),
		Switch(Id("probe").Dot("Type")).Block(
			Case(Lit("text")).Block(
				Var().Id("v").Id("TextContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Text").Op("=").Op("&").Id("v"),
			),
			Case(Lit("image")).Block(
				Var().Id("v").Id("ImageContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Image").Op("=").Op("&").Id("v"),
			),
			Case(Lit("audio")).Block(
				Var().Id("v").Id("AudioContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Audio").Op("=").Op("&").Id("v"),
			),
			Case(Lit("resource_link")).Block(
				Var().Id("v").Id("ResourceLinkContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("ResourceLink").Op("=").Op("&").Id("v"),
			),
			Case(Lit("resource")).Block(
				Var().Id("v").Id("EmbeddedResource"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Resource").Op("=").Op("&").Id("v"),
			),
		),
		Return(Nil()),
	)
	// MarshalJSON for ContentBlock
	f.Func().Params(Id("c").Id("ContentBlock")).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).Block(
		Switch(Id("c").Dot("Type")).Block(
			Case(Lit("text")).Block(
				If(Id("c").Dot("Text").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"): Lit("text"),
						Lit("text"): Id("c").Dot("Text").Dot("Text"),
					}))),
				),
			),
			Case(Lit("image")).Block(
				If(Id("c").Dot("Image").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):     Lit("image"),
						Lit("data"):     Id("c").Dot("Image").Dot("Data"),
						Lit("mimeType"): Id("c").Dot("Image").Dot("MimeType"),
						Lit("uri"):      Id("c").Dot("Image").Dot("Uri"),
					}))),
				),
			),
			Case(Lit("audio")).Block(
				If(Id("c").Dot("Audio").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):     Lit("audio"),
						Lit("data"):     Id("c").Dot("Audio").Dot("Data"),
						Lit("mimeType"): Id("c").Dot("Audio").Dot("MimeType"),
					}))),
				),
			),
			Case(Lit("resource_link")).Block(
				If(Id("c").Dot("ResourceLink").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):        Lit("resource_link"),
						Lit("name"):        Id("c").Dot("ResourceLink").Dot("Name"),
						Lit("uri"):         Id("c").Dot("ResourceLink").Dot("Uri"),
						Lit("description"): Id("c").Dot("ResourceLink").Dot("Description"),
						Lit("mimeType"):    Id("c").Dot("ResourceLink").Dot("MimeType"),
						Lit("size"):        Id("c").Dot("ResourceLink").Dot("Size"),
						Lit("title"):       Id("c").Dot("ResourceLink").Dot("Title"),
					}))),
				),
			),
			Case(Lit("resource")).Block(
				If(Id("c").Dot("Resource").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):     Lit("resource"),
						Lit("resource"): Id("c").Dot("Resource").Dot("Resource"),
					}))),
				),
			),
		),
		Return(Index().Byte().Values(), Nil()),
	)
	f.Line()
}

func emitToolCallContentJen(f *File) {
	// Helpers
	f.Type().Id("DiffContent").Struct(
		Id("NewText").String().Tag(map[string]string{"json": "newText"}),
		Id("OldText").Op("*").String().Tag(map[string]string{"json": "oldText,omitempty"}),
		Id("Path").String().Tag(map[string]string{"json": "path"}),
	)
	f.Type().Id("TerminalRef").Struct(Id("TerminalId").String().Tag(map[string]string{"json": "terminalId"}))
	f.Line()
	// ToolCallContent
	f.Type().Id("ToolCallContent").Struct(
		Id("Type").String().Tag(map[string]string{"json": "type"}),
		Id("Content").Op("*").Id("ContentBlock").Tag(map[string]string{"json": "-"}),
		Id("Diff").Op("*").Id("DiffContent").Tag(map[string]string{"json": "-"}),
		Id("Terminal").Op("*").Id("TerminalRef").Tag(map[string]string{"json": "-"}),
	)
	f.Line()
	// UnmarshalJSON
	f.Func().Params(Id("t").Op("*").Id("ToolCallContent")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("probe").Struct(Id("Type").String().Tag(map[string]string{"json": "type"})),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("probe")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Id("t").Dot("Type").Op("=").Id("probe").Dot("Type"),
		Switch(Id("probe").Dot("Type")).Block(
			Case(Lit("content")).Block(
				Var().Id("v").Struct(
					Id("Type").String().Tag(map[string]string{"json": "type"}),
					Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}),
				),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("t").Dot("Content").Op("=").Op("&").Id("v").Dot("Content"),
			),
			Case(Lit("diff")).Block(
				Var().Id("v").Id("DiffContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("t").Dot("Diff").Op("=").Op("&").Id("v"),
			),
			Case(Lit("terminal")).Block(
				Var().Id("v").Id("TerminalRef"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("t").Dot("Terminal").Op("=").Op("&").Id("v"),
			),
		),
		Return(Nil()),
	)
	f.Line()
}

func emitEmbeddedResourceResourceJen(f *File) {
	// Holder with pointers to known variants
	f.Type().Id("EmbeddedResourceResource").Struct(
		Id("TextResourceContents").Op("*").Id("TextResourceContents").Tag(map[string]string{"json": "-"}),
		Id("BlobResourceContents").Op("*").Id("BlobResourceContents").Tag(map[string]string{"json": "-"}),
	)
	f.Line()
	f.Func().Params(Id("e").Op("*").Id("EmbeddedResourceResource")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		// Decide by presence of distinguishing keys
		Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage"),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		// TextResourceContents has "text" key
		If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit("text")), Id("ok")).Block(
			Var().Id("v").Id("TextResourceContents"),
			If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
			Id("e").Dot("TextResourceContents").Op("=").Op("&").Id("v"),
			Return(Nil()),
		),
		// BlobResourceContents has "blob" key
		If(List(Id("_"), Id("ok2")).Op(":=").Id("m").Index(Lit("blob")), Id("ok2")).Block(
			Var().Id("v").Id("BlobResourceContents"),
			If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
			Id("e").Dot("BlobResourceContents").Op("=").Op("&").Id("v"),
			Return(Nil()),
		),
		Return(Nil()),
	)
	f.Line()
}

func emitRequestPermissionOutcomeJen(f *File) {
	// Variants
	f.Type().Id("RequestPermissionOutcomeCancelled").Struct()
	f.Type().Id("RequestPermissionOutcomeSelected").Struct(
		Id("OptionId").Id("PermissionOptionId").Tag(map[string]string{"json": "optionId"}),
	)
	f.Line()
	// Holder
	f.Type().Id("RequestPermissionOutcome").Struct(
		Id("Cancelled").Op("*").Id("RequestPermissionOutcomeCancelled").Tag(map[string]string{"json": "-"}),
		Id("Selected").Op("*").Id("RequestPermissionOutcomeSelected").Tag(map[string]string{"json": "-"}),
	)
	f.Func().Params(Id("o").Op("*").Id("RequestPermissionOutcome")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage"),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Var().Id("outcome").String(),
		If(List(Id("v"), Id("ok")).Op(":=").Id("m").Index(Lit("outcome")), Id("ok")).Block(
			Qual("encoding/json", "Unmarshal").Call(Id("v"), Op("&").Id("outcome")),
		),
		Switch(Id("outcome")).Block(
			Case(Lit("cancelled")).Block(
				Id("o").Dot("Cancelled").Op("=").Op("&").Id("RequestPermissionOutcomeCancelled").Values(),
				Return(Nil()),
			),
			Case(Lit("selected")).Block(
				Var().Id("v2").Id("RequestPermissionOutcomeSelected"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v2")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("o").Dot("Selected").Op("=").Op("&").Id("v2"),
				Return(Nil()),
			),
		),
		Return(Nil()),
	)
	// MarshalJSON
	f.Func().Params(Id("o").Id("RequestPermissionOutcome")).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).Block(
		If(Id("o").Dot("Cancelled").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{Lit("outcome"): Lit("cancelled")}))),
		),
		If(Id("o").Dot("Selected").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("outcome"):  Lit("selected"),
				Lit("optionId"): Id("o").Dot("Selected").Dot("OptionId"),
			}))),
		),
		Return(Index().Byte().Values(), Nil()),
	)
	f.Line()
}

func emitSessionUpdateJen(f *File) {
	// Variant types
	f.Type().Id("SessionUpdateUserMessageChunk").Struct(
		Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}),
	)
	f.Type().Id("SessionUpdateAgentMessageChunk").Struct(
		Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}),
	)
	f.Type().Id("SessionUpdateAgentThoughtChunk").Struct(
		Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}),
	)
	f.Type().Id("SessionUpdateToolCall").Struct(
		Id("Content").Index().Id("ToolCallContent").Tag(map[string]string{"json": "content,omitempty"}),
		Id("Kind").Id("ToolKind").Tag(map[string]string{"json": "kind,omitempty"}),
		Id("Locations").Index().Id("ToolCallLocation").Tag(map[string]string{"json": "locations,omitempty"}),
		Id("RawInput").Any().Tag(map[string]string{"json": "rawInput,omitempty"}),
		Id("RawOutput").Any().Tag(map[string]string{"json": "rawOutput,omitempty"}),
		Id("Status").Id("ToolCallStatus").Tag(map[string]string{"json": "status,omitempty"}),
		Id("Title").String().Tag(map[string]string{"json": "title"}),
		Id("ToolCallId").Id("ToolCallId").Tag(map[string]string{"json": "toolCallId"}),
	)
	f.Type().Id("SessionUpdateToolCallUpdate").Struct(
		Id("Content").Index().Id("ToolCallContent").Tag(map[string]string{"json": "content,omitempty"}),
		Id("Kind").Any().Tag(map[string]string{"json": "kind,omitempty"}),
		Id("Locations").Index().Id("ToolCallLocation").Tag(map[string]string{"json": "locations,omitempty"}),
		Id("RawInput").Any().Tag(map[string]string{"json": "rawInput,omitempty"}),
		Id("RawOutput").Any().Tag(map[string]string{"json": "rawOutput,omitempty"}),
		Id("Status").Any().Tag(map[string]string{"json": "status,omitempty"}),
		Id("Title").Op("*").String().Tag(map[string]string{"json": "title,omitempty"}),
		Id("ToolCallId").Id("ToolCallId").Tag(map[string]string{"json": "toolCallId"}),
	)
	f.Type().Id("SessionUpdatePlan").Struct(
		Id("Entries").Index().Id("PlanEntry").Tag(map[string]string{"json": "entries"}),
	)
	f.Line()
	// Holder
	f.Type().Id("SessionUpdate").Struct(
		Id("UserMessageChunk").Op("*").Id("SessionUpdateUserMessageChunk").Tag(map[string]string{"json": "-"}),
		Id("AgentMessageChunk").Op("*").Id("SessionUpdateAgentMessageChunk").Tag(map[string]string{"json": "-"}),
		Id("AgentThoughtChunk").Op("*").Id("SessionUpdateAgentThoughtChunk").Tag(map[string]string{"json": "-"}),
		Id("ToolCall").Op("*").Id("SessionUpdateToolCall").Tag(map[string]string{"json": "-"}),
		Id("ToolCallUpdate").Op("*").Id("SessionUpdateToolCallUpdate").Tag(map[string]string{"json": "-"}),
		Id("Plan").Op("*").Id("SessionUpdatePlan").Tag(map[string]string{"json": "-"}),
	)
	f.Func().Params(Id("s").Op("*").Id("SessionUpdate")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage"),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Var().Id("kind").String(),
		If(List(Id("v"), Id("ok")).Op(":=").Id("m").Index(Lit("sessionUpdate")), Id("ok")).Block(
			Qual("encoding/json", "Unmarshal").Call(Id("v"), Op("&").Id("kind")),
		),
		Switch(Id("kind")).Block(
			Case(Lit("user_message_chunk")).Block(
				Var().Id("v").Id("SessionUpdateUserMessageChunk"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("UserMessageChunk").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("agent_message_chunk")).Block(
				Var().Id("v").Id("SessionUpdateAgentMessageChunk"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("AgentMessageChunk").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("agent_thought_chunk")).Block(
				Var().Id("v").Id("SessionUpdateAgentThoughtChunk"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("AgentThoughtChunk").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("tool_call")).Block(
				Var().Id("v").Id("SessionUpdateToolCall"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("ToolCall").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("tool_call_update")).Block(
				Var().Id("v").Id("SessionUpdateToolCallUpdate"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("ToolCallUpdate").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("plan")).Block(
				Var().Id("v").Id("SessionUpdatePlan"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("Plan").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
		),
		Return(Nil()),
	)
	// MarshalJSON
	f.Func().Params(Id("s").Id("SessionUpdate")).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).Block(
		If(Id("s").Dot("UserMessageChunk").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("user_message_chunk"),
				Lit("content"):       Id("s").Dot("UserMessageChunk").Dot("Content"),
			}))),
		),
		If(Id("s").Dot("AgentMessageChunk").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("agent_message_chunk"),
				Lit("content"):       Id("s").Dot("AgentMessageChunk").Dot("Content"),
			}))),
		),
		If(Id("s").Dot("AgentThoughtChunk").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("agent_thought_chunk"),
				Lit("content"):       Id("s").Dot("AgentThoughtChunk").Dot("Content"),
			}))),
		),
		If(Id("s").Dot("ToolCall").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("tool_call"),
				Lit("content"):       Id("s").Dot("ToolCall").Dot("Content"),
				Lit("kind"):          Id("s").Dot("ToolCall").Dot("Kind"),
				Lit("locations"):     Id("s").Dot("ToolCall").Dot("Locations"),
				Lit("rawInput"):      Id("s").Dot("ToolCall").Dot("RawInput"),
				Lit("rawOutput"):     Id("s").Dot("ToolCall").Dot("RawOutput"),
				Lit("status"):        Id("s").Dot("ToolCall").Dot("Status"),
				Lit("title"):         Id("s").Dot("ToolCall").Dot("Title"),
				Lit("toolCallId"):    Id("s").Dot("ToolCall").Dot("ToolCallId"),
			}))),
		),
		If(Id("s").Dot("ToolCallUpdate").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("tool_call_update"),
				Lit("content"):       Id("s").Dot("ToolCallUpdate").Dot("Content"),
				Lit("kind"):          Id("s").Dot("ToolCallUpdate").Dot("Kind"),
				Lit("locations"):     Id("s").Dot("ToolCallUpdate").Dot("Locations"),
				Lit("rawInput"):      Id("s").Dot("ToolCallUpdate").Dot("RawInput"),
				Lit("rawOutput"):     Id("s").Dot("ToolCallUpdate").Dot("RawOutput"),
				Lit("status"):        Id("s").Dot("ToolCallUpdate").Dot("Status"),
				Lit("title"):         Id("s").Dot("ToolCallUpdate").Dot("Title"),
				Lit("toolCallId"):    Id("s").Dot("ToolCallUpdate").Dot("ToolCallId"),
			}))),
		),
		If(Id("s").Dot("Plan").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("plan"),
				Lit("entries"):       Id("s").Dot("Plan").Dot("Entries"),
			}))),
		),
		Return(Index().Byte().Values(), Nil()),
	)
	f.Line()
}

func primitiveJenType(t string) Code {
	switch t {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	default:
		return Any()
	}
}

func jenTypeFor(d *Definition) Code {
	if d == nil {
		return Any()
	}
	if d.Ref != "" {
		if strings.HasPrefix(d.Ref, "#/$defs/") {
			return Id(d.Ref[len("#/$defs/"):])
		}
		return Any()
	}
	if len(d.Enum) > 0 {
		return String()
	}
	switch primaryType(d) {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	case "array":
		return Index().Add(jenTypeFor(d.Items))
	case "object":
		if len(d.Properties) == 0 {
			return Map(String()).Any()
		}
		return Map(String()).Any()
	default:
		if len(d.AnyOf) > 0 || len(d.OneOf) > 0 {
			return Any()
		}
		return Any()
	}
}

// jenTypeForOptional maps unions that include null to pointer types where applicable.
func jenTypeForOptional(d *Definition) Code {
	if d == nil {
		return Any()
	}
	// Check anyOf/oneOf with exactly one non-null + null
	list := d.AnyOf
	if len(list) == 0 {
		list = d.OneOf
	}
	if len(list) == 2 {
		var nonNull *Definition
		for _, e := range list {
			if e == nil {
				continue
			}
			if s, ok := e.Type.(string); ok && s == "null" {
				continue
			}
			if e.Const != nil {
				nn := *e
				nn.Type = "string"
				nonNull = &nn
			} else {
				nonNull = e
			}
		}
		if nonNull != nil {
			if nonNull.Ref != "" && strings.HasPrefix(nonNull.Ref, "#/$defs/") {
				return Op("*").Id(nonNull.Ref[len("#/$defs/"):])
			}
			switch primaryType(nonNull) {
			case "string":
				return Op("*").String()
			case "integer":
				return Op("*").Int()
			case "number":
				return Op("*").Float64()
			case "boolean":
				return Op("*").Bool()
			}
		}
	}
	return jenTypeFor(d)
}

func isNullResponse(def *Definition) bool {
	if def == nil {
		return true
	}
	// type: null or oneOf with const null (unlikely here)
	if s, ok := def.Type.(string); ok && s == "null" {
		return true
	}
	return false
}

func dispatchMethodNameForNotification(methodKey, typeName string) string {
	switch methodKey {
	case "session_update":
		return "SessionUpdate"
	case "session_cancel":
		return "Cancel"
	default:
		// Fallback to type base without suffix
		if strings.HasSuffix(typeName, "Notification") {
			return strings.TrimSuffix(typeName, "Notification")
		}
		return typeName
	}
}

func writeDispatchJen(outDir string, schema *Schema, meta *Meta) error {
	// Build method groups using schema + meta inference
	groups := buildMethodGroups(schema, meta)

	// Agent handler method
	fAgent := NewFile("acp")
	fAgent.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")
	// func (a *AgentSideConnection) handle(method string, params json.RawMessage) (any, *RequestError) { switch method { ... } }
	switchCases := []Code{}
	// deterministic order via meta.AgentMethods
	amKeys := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys = append(amKeys, k)
	}
	sort.Strings(amKeys)
	for _, k := range amKeys {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		caseBody := []Code{}
		if mi.Notif != "" {
			// var p T; if err := json.Unmarshal(params, &p); err != nil { return nil, NewInvalidParams(...) }
			caseBody = append(caseBody,
				Var().Id("p").Id(mi.Notif),
				If(
					List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("params"), Op("&").Id("p")),
					Id("err").Op("!=").Nil(),
				).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
				// Validate if available
				If(List(Id("err")).Op(":=").Id("p").Dot("Validate").Call(), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
			)
			// if err := a.agent.Call(p); err != nil { return nil, toReqErr(err) }; return nil, nil
			callName := dispatchMethodNameForNotification(k, mi.Notif)
			caseBody = append(caseBody,
				If(
					List(Id("err")).Op(":=").Id("a").Dot("agent").Dot(callName).Call(Id("p")),
					Id("err").Op("!=").Nil(),
				).Block(
					Return(Nil(), Id("toReqErr").Call(Id("err"))),
				),
				Return(Nil(), Nil()),
			)
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			caseBody = append(caseBody,
				Var().Id("p").Id(mi.Req),
				If(
					List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("params"), Op("&").Id("p")),
					Id("err").Op("!=").Nil(),
				).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
				If(List(Id("err")).Op(":=").Id("p").Dot("Validate").Call(), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
			)
			methodName := strings.TrimSuffix(mi.Req, "Request")
			// Optional: session/load lives on AgentLoader
			if wire == "session/load" {
				// Perform type assertion first, then branch
				caseBody = append(caseBody,
					List(Id("loader"), Id("ok")).Op(":=").Id("a").Dot("agent").Assert(Id("AgentLoader")),
					If(Op("!").Id("ok")).Block(
						Return(Nil(), Id("NewMethodNotFound").Call(Id("method"))),
					),
				)
				if isNullResponse(schema.Defs[respName]) {
					caseBody = append(caseBody,
						If(
							List(Id("err")).Op(":=").Id("loader").Dot(methodName).Call(Id("p")),
							Id("err").Op("!=").Nil(),
						).Block(
							Return(Nil(), Id("toReqErr").Call(Id("err"))),
						),
						Return(Nil(), Nil()),
					)
				} else {
					caseBody = append(caseBody,
						List(Id("resp"), Id("err")).Op(":=").Id("loader").Dot(methodName).Call(Id("p")),
						If(Id("err").Op("!=").Nil()).Block(Return(Nil(), Id("toReqErr").Call(Id("err")))),
						Return(Id("resp"), Nil()),
					)
				}
			} else if isDocsIgnoredMethod(schema, mi) {
				// Undocumented/experimental agent methods require AgentExperimental
				caseBody = append(caseBody,
					List(Id("exp"), Id("ok")).Op(":=").Id("a").Dot("agent").Assert(Id("AgentExperimental")),
					If(Op("!").Id("ok")).Block(
						Return(Nil(), Id("NewMethodNotFound").Call(Id("method"))),
					),
				)
				if isNullResponse(schema.Defs[respName]) {
					caseBody = append(caseBody,
						If(
							List(Id("err")).Op(":=").Id("exp").Dot(methodName).Call(Id("p")),
							Id("err").Op("!=").Nil(),
						).Block(
							Return(Nil(), Id("toReqErr").Call(Id("err"))),
						),
						Return(Nil(), Nil()),
					)
				} else {
					caseBody = append(caseBody,
						List(Id("resp"), Id("err")).Op(":=").Id("exp").Dot(methodName).Call(Id("p")),
						If(Id("err").Op("!=").Nil()).Block(Return(Nil(), Id("toReqErr").Call(Id("err")))),
						Return(Id("resp"), Nil()),
					)
				}
			} else {
				if isNullResponse(schema.Defs[respName]) {
					caseBody = append(caseBody,
						If(
							List(Id("err")).Op(":=").Id("a").Dot("agent").Dot(methodName).Call(Id("p")),
							Id("err").Op("!=").Nil(),
						).Block(
							Return(Nil(), Id("toReqErr").Call(Id("err"))),
						),
						Return(Nil(), Nil()),
					)
				} else {
					caseBody = append(caseBody,
						List(Id("resp"), Id("err")).Op(":=").Id("a").Dot("agent").Dot(methodName).Call(Id("p")),
						If(Id("err").Op("!=").Nil()).Block(Return(Nil(), Id("toReqErr").Call(Id("err")))),
						Return(Id("resp"), Nil()),
					)
				}
			}
		}
		if len(caseBody) > 0 {
			switchCases = append(switchCases, Case(Id("AgentMethod"+toExportedConst(k))).Block(caseBody...))
		}
	}
	switchCases = append(switchCases, Default().Block(Return(Nil(), Id("NewMethodNotFound").Call(Id("method")))))
	fAgent.Func().Params(Id("a").Op("*").Id("AgentSideConnection")).Id("handle").Params(
		Id("method").String(),
		Id("params").Qual("encoding/json", "RawMessage"),
	).Params(Any(), Op("*").Id("RequestError")).Block(
		Switch(Id("method")).Block(switchCases...),
	)
	// After generating the handler, also append outbound wrappers for AgentSideConnection
	// Build const name reverse lookup
	agentConst := map[string]string{}
	for k, v := range meta.AgentMethods {
		agentConst[v] = "AgentMethod" + toExportedConst(k)
	}
	clientConst := map[string]string{}
	for k, v := range meta.ClientMethods {
		clientConst[v] = "ClientMethod" + toExportedConst(k)
	}
	// Agent outbound: methods the agent can call on the client (stable order)
	cmKeys2 := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys2 = append(cmKeys2, k)
	}
	sort.Strings(cmKeys2)
	for _, k := range cmKeys2 {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		constName := clientConst[mi.Method]
		if constName == "" {
			continue
		}
		if mi.Notif != "" {
			name := strings.TrimSuffix(mi.Notif, "Notification")
			switch mi.Method {
			case "session/update":
				name = "SessionUpdate"
			case "session/cancel":
				name = "Cancel"
			}
			fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(name).Params(Id("params").Id(mi.Notif)).Error().
				Block(Return(Id("c").Dot("conn").Dot("SendNotification").Call(Id(constName), Id("params"))))
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			if isNullResponse(schema.Defs[respName]) {
				fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Error().
					Block(Return(Id("c").Dot("conn").Dot("SendRequestNoResult").Call(Id(constName), Id("params"))))
			} else {
				fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()).
					Block(
						List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id(constName), Id("params")),
						Return(Id("resp"), Id("err")),
					)
			}
		}
	}
	var bufA bytes.Buffer
	if err := fAgent.Render(&bufA); err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(outDir, "agent_gen.go"), bufA.Bytes(), 0o644); err != nil {
		return err
	}

	// Client handler method
	fClient := NewFile("acp")
	fClient.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")
	cCases := []Code{}
	cmKeys := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys = append(cmKeys, k)
	}
	sort.Strings(cmKeys)
	for _, k := range cmKeys {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		body := []Code{}
		if mi.Notif != "" {
			body = append(body,
				Var().Id("p").Id(mi.Notif),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("params"), Op("&").Id("p")), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
				If(List(Id("err")).Op(":=").Id("p").Dot("Validate").Call(), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
			)
			callName := dispatchMethodNameForNotification(k, mi.Notif)
			body = append(body,
				If(List(Id("err")).Op(":=").Id("c").Dot("client").Dot(callName).Call(Id("p")), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("toReqErr").Call(Id("err"))),
				),
				Return(Nil(), Nil()),
			)
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			body = append(body,
				Var().Id("p").Id(mi.Req),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("params"), Op("&").Id("p")), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
				If(List(Id("err")).Op(":=").Id("p").Dot("Validate").Call(), Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Id("NewInvalidParams").Call(Map(String()).Id("any").Values(Dict{Lit("error"): Id("err").Dot("Error").Call()}))),
				),
			)
			methodName := strings.TrimSuffix(mi.Req, "Request")
			// Optional/experimental undocumented methods: require ClientExperimental
			if isDocsIgnoredMethod(schema, mi) {
				// Perform type assertion first, then branch
				body = append(body,
					List(Id("t"), Id("ok")).Op(":=").Id("c").Dot("client").Assert(Id("ClientExperimental")),
					If(Op("!").Id("ok")).Block(
						Return(Nil(), Id("NewMethodNotFound").Call(Id("method"))),
					),
				)
				if isNullResponse(schema.Defs[respName]) {
					body = append(body,
						If(List(Id("err")).Op(":=").Id("t").Dot(methodName).Call(Id("p")), Id("err").Op("!=").Nil()).Block(
							Return(Nil(), Id("toReqErr").Call(Id("err"))),
						),
						Return(Nil(), Nil()),
					)
				} else {
					body = append(body,
						List(Id("resp"), Id("err")).Op(":=").Id("t").Dot(methodName).Call(Id("p")),
						If(Id("err").Op("!=").Nil()).Block(Return(Nil(), Id("toReqErr").Call(Id("err")))),
						Return(Id("resp"), Nil()),
					)
				}
			} else {
				if isNullResponse(schema.Defs[respName]) {
					body = append(body,
						If(List(Id("err")).Op(":=").Id("c").Dot("client").Dot(methodName).Call(Id("p")), Id("err").Op("!=").Nil()).Block(
							Return(Nil(), Id("toReqErr").Call(Id("err"))),
						),
						Return(Nil(), Nil()),
					)
				} else {
					body = append(body,
						List(Id("resp"), Id("err")).Op(":=").Id("c").Dot("client").Dot(methodName).Call(Id("p")),
						If(Id("err").Op("!=").Nil()).Block(Return(Nil(), Id("toReqErr").Call(Id("err")))),
						Return(Id("resp"), Nil()),
					)
				}
			}
		}
		if len(body) > 0 {
			cCases = append(cCases, Case(Id("ClientMethod"+toExportedConst(k))).Block(body...))
		}
	}
	cCases = append(cCases, Default().Block(Return(Nil(), Id("NewMethodNotFound").Call(Id("method")))))
	fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id("handle").Params(
		Id("method").String(), Id("params").Qual("encoding/json", "RawMessage")).Params(
		Any(), Op("*").Id("RequestError")).Block(
		Switch(Id("method")).Block(cCases...),
	)
	// After generating the handler, also append outbound wrappers for ClientSideConnection
	// Client outbound: methods the client can call on the agent (stable order)
	amKeys2 := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys2 = append(amKeys2, k)
	}
	sort.Strings(amKeys2)
	for _, k := range amKeys2 {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		constName := agentConst[mi.Method]
		if constName == "" {
			continue
		}
		if mi.Notif != "" {
			name := strings.TrimSuffix(mi.Notif, "Notification")
			switch mi.Method {
			case "session/update":
				name = "SessionUpdate"
			case "session/cancel":
				name = "Cancel"
			}
			fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(name).Params(Id("params").Id(mi.Notif)).Error().
				Block(Return(Id("c").Dot("conn").Dot("SendNotification").Call(Id(constName), Id("params"))))
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			if isNullResponse(schema.Defs[respName]) {
				fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Error().
					Block(Return(Id("c").Dot("conn").Dot("SendRequestNoResult").Call(Id(constName), Id("params"))))
			} else {
				fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()).
					Block(
						List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id(constName), Id("params")),
						Return(Id("resp"), Id("err")),
					)
			}
		}
	}
	var bufC bytes.Buffer
	if err := fClient.Render(&bufC); err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(outDir, "client_gen.go"), bufC.Bytes(), 0o644); err != nil {
		return err
	}

	// Clean up old split outbound files if present
	_ = os.Remove(filepath.Join(outDir, "agent_outbound_gen.go"))
	_ = os.Remove(filepath.Join(outDir, "client_outbound_gen.go"))
	return nil
}

func sanitizeComment(s string) string {
	// Remove backticks and normalize newlines
	s = strings.ReplaceAll(s, "`", "'")
	lines := strings.Split(s, "\n")
	for i := range lines {
		lines[i] = strings.TrimSpace(lines[i])
	}
	return strings.Join(lines, " ")
}

func primaryType(d *Definition) string {
	if d == nil || d.Type == nil {
		return ""
	}
	switch v := d.Type.(type) {
	case string:
		return v
	case []any:
		// choose a non-null type if present
		var first string
		for _, e := range v {
			if s, ok := e.(string); ok {
				if first == "" {
					first = s
				}
				if s != "null" {
					return s
				}
			}
		}
		return first
	default:
		return ""
	}
}

func toExportedField(name string) string {
	// Convert camelCase or snake_case to PascalCase; keep common acronyms minimal (ID -> Id)
	// First, split on underscores
	parts := strings.Split(name, "_")
	if len(parts) == 1 {
		// handle camelCase
		parts = splitCamel(name)
	}
	for i := range parts {
		parts[i] = titleWord(parts[i])
	}
	return strings.Join(parts, "")
}

func splitCamel(s string) []string {
	var parts []string
	last := 0
	for i := 1; i < len(s); i++ {
		if isBoundary(s[i-1], s[i]) {
			parts = append(parts, s[last:i])
			last = i
		}
	}
	parts = append(parts, s[last:])
	return parts
}

func isBoundary(prev, curr byte) bool {
	return (prev >= 'a' && prev <= 'z' && curr >= 'A' && curr <= 'Z') || curr == '_'
}

func toEnumConst(typeName, val string) string {
	// Build CONST like <TypeName><Value>
	// Normalize value: replace non-alnum with underscores, split by underscores or spaces, title-case.
	cleaned := make([]rune, 0, len(val))
	for _, r := range val {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			cleaned = append(cleaned, r)
		} else {
			cleaned = append(cleaned, '_')
		}
	}
	parts := strings.FieldsFunc(string(cleaned), func(r rune) bool { return r == '_' })
	for i := range parts {
		parts[i] = titleWord(strings.ToLower(parts[i]))
	}
	return typeName + strings.Join(parts, "")
}

func titleWord(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	for i := 1; i < len(r); i++ {
		r[i] = unicode.ToLower(r[i])
	}
	return string(r)
}
