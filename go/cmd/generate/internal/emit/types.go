package emit

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/ir"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/util"
)

// WriteTypesJen emits go/types_gen.go with all types and the Agent/Client interfaces.
func WriteTypesJen(outDir string, schema *load.Schema, meta *load.Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	// Deterministic order
	keys := make([]string, 0, len(schema.Defs))
	for k := range schema.Defs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, name := range keys {
		def := schema.Defs[name]
		if def == nil {
			continue
		}

		if def.Description != "" {
			f.Comment(util.SanitizeComment(def.Description))
		}

		switch {
		case len(def.Enum) > 0:
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.Enum {
				s := fmt.Sprint(v)
				defs = append(defs, Id(util.ToEnumConst(name, s)).Id(name).Op("=").Lit(s))
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case isStringConstUnion(def):
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.OneOf {
				if v != nil && v.Const != nil {
					s := fmt.Sprint(v.Const)
					defs = append(defs, Id(util.ToEnumConst(name, s)).Id(name).Op("=").Lit(s))
				}
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case name == "ContentBlock":
			emitContentBlockJen(f)
		case name == "ToolCallContent":
			emitToolCallContentJen(f)
		case name == "EmbeddedResourceResource":
			emitEmbeddedResourceResourceJen(f)
		case name == "RequestPermissionOutcome":
			emitRequestPermissionOutcomeJen(f)
		case name == "SessionUpdate":
			emitSessionUpdateJen(f)
		case ir.PrimaryType(def) == "object" && len(def.Properties) > 0:
			st := []Code{}
			req := map[string]struct{}{}
			for _, r := range def.Required {
				req[r] = struct{}{}
			}
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, pk := range pkeys {
				prop := def.Properties[pk]
				field := util.ToExportedField(pk)
				if prop.Description != "" {
					st = append(st, Comment(util.SanitizeComment(prop.Description)))
				}
				tag := pk
				if _, ok := req[pk]; !ok {
					tag = pk + ",omitempty"
				}
				st = append(st, Id(field).Add(jenTypeForOptional(prop)).Tag(map[string]string{"json": tag}))
			}
			f.Type().Id(name).Struct(st...)
			f.Line()
		case ir.PrimaryType(def) == "string" || ir.PrimaryType(def) == "integer" || ir.PrimaryType(def) == "number" || ir.PrimaryType(def) == "boolean":
			f.Type().Id(name).Add(primitiveJenType(ir.PrimaryType(def)))
			f.Line()
		default:
			f.Comment(fmt.Sprintf("%s is a union or complex schema; represented generically.", name))
			f.Type().Id(name).Any()
			f.Line()
		}

		// validators for selected types
		if strings.HasSuffix(name, "Request") || strings.HasSuffix(name, "Response") || strings.HasSuffix(name, "Notification") || name == "ContentBlock" || name == "ToolCallContent" || name == "SessionUpdate" || name == "ToolCallUpdate" {
			emitValidateJen(f, name, def)
		}
	}

	// Append Agent & Client interfaces from method groups
	groups := ir.BuildMethodGroups(schema, meta)

	// Agent
	agentMethods := []Code{}
	agentLoaderMethods := []Code{}
	agentExperimentalMethods := []Code{}
	for _, k := range ir.SortedKeys(meta.AgentMethods) {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		target := &agentMethods
		switch mi.Binding {
		case ir.BindAgentLoader:
			target = &agentLoaderMethods
		case ir.BindAgentExperimental:
			target = &agentExperimentalMethods
		}
		if mi.Notif != "" {
			name := ir.DispatchMethodNameForNotification(k, mi.Notif)
			*target = append(*target, Id(name).Params(Id("params").Id(mi.Notif)).Error())
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			methodName := strings.TrimSuffix(mi.Req, "Request")
			if ir.IsNullResponse(schema.Defs[respName]) {
				*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Error())
			} else {
				*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()))
			}
		}
	}
	f.Type().Id("Agent").Interface(agentMethods...)
	if len(agentLoaderMethods) > 0 {
		f.Comment("AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.")
		f.Type().Id("AgentLoader").Interface(agentLoaderMethods...)
	}
	if len(agentExperimentalMethods) > 0 {
		f.Comment("AgentExperimental defines undocumented/experimental methods (x-docs-ignore). These may change or be removed without notice.")
		f.Type().Id("AgentExperimental").Interface(agentExperimentalMethods...)
	}

	// Client
	clientStable := []Code{}
	clientExperimental := []Code{}
	clientTerminal := []Code{}
	for _, k := range ir.SortedKeys(meta.ClientMethods) {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		target := &clientStable
		switch mi.Binding {
		case ir.BindClientExperimental:
			target = &clientExperimental
		case ir.BindClientTerminal:
			target = &clientTerminal
		}
		if mi.Notif != "" {
			name := ir.DispatchMethodNameForNotification(k, mi.Notif)
			*target = append(*target, Id(name).Params(Id("params").Id(mi.Notif)).Error())
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			methodName := strings.TrimSuffix(mi.Req, "Request")
			if ir.IsNullResponse(schema.Defs[respName]) {
				*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Error())
			} else {
				*target = append(*target, Id(methodName).Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()))
			}
		}
	}
	f.Type().Id("Client").Interface(clientStable...)
	if len(clientTerminal) > 0 {
		f.Comment("ClientTerminal defines terminal-related experimental methods (x-docs-ignore). Implement and advertise 'terminal: true' to enable 'terminal/*'.")
		f.Type().Id("ClientTerminal").Interface(clientTerminal...)
	}
	if len(clientExperimental) > 0 {
		f.Comment("ClientExperimental defines undocumented/experimental methods (x-docs-ignore) other than terminals. These may change or be removed without notice.")
		f.Type().Id("ClientExperimental").Interface(clientExperimental...)
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "types_gen.go"), buf.Bytes(), 0o644)
}

func isStringConstUnion(def *load.Definition) bool {
	if def == nil || len(def.OneOf) == 0 {
		return false
	}
	for _, v := range def.OneOf {
		if v == nil || v.Const == nil {
			return false
		}
		if _, ok := v.Const.(string); !ok {
			return false
		}
	}
	return true
}

// emitValidateJen generates validators for selected types (logic unchanged).
func emitValidateJen(f *File, name string, def *load.Definition) {
	switch name {
	case "ContentBlock":
		f.Func().Params(Id("c").Op("*").Id("ContentBlock")).Id("Validate").Params().Params(Error()).Block(
			Switch(Id("c").Dot("Type")).Block(
				Case(Lit("text")).Block(If(Id("c").Dot("Text").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.text missing"))))),
				Case(Lit("image")).Block(If(Id("c").Dot("Image").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.image missing"))))),
				Case(Lit("audio")).Block(If(Id("c").Dot("Audio").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.audio missing"))))),
				Case(Lit("resource_link")).Block(If(Id("c").Dot("ResourceLink").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.resource_link missing"))))),
				Case(Lit("resource")).Block(If(Id("c").Dot("Resource").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("contentblock.resource missing"))))),
			),
			Return(Nil()),
		)
		return
	case "ToolCallContent":
		f.Func().Params(Id("t").Op("*").Id("ToolCallContent")).Id("Validate").Params().Params(Error()).Block(
			Switch(Id("t").Dot("Type")).Block(
				Case(Lit("content")).Block(If(Id("t").Dot("Content").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolcallcontent.content missing"))))),
				Case(Lit("diff")).Block(If(Id("t").Dot("Diff").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolcallcontent.diff missing"))))),
				Case(Lit("terminal")).Block(If(Id("t").Dot("Terminal").Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolcallcontent.terminal missing"))))),
			),
			Return(Nil()),
		)
		return
	case "SessionUpdate":
		f.Func().Params(Id("s").Op("*").Id("SessionUpdate")).Id("Validate").Params().Params(Error()).Block(
			Var().Id("count").Int(),
			If(Id("s").Dot("UserMessageChunk").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("AgentMessageChunk").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("AgentThoughtChunk").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("ToolCall").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("ToolCallUpdate").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("s").Dot("Plan").Op("!=").Nil()).Block(Id("count").Op("++")),
			If(Id("count").Op("!=").Lit(1)).Block(Return(Qual("fmt", "Errorf").Call(Lit("sessionupdate must have exactly one variant set")))),
			Return(Nil()),
		)
		return
	case "ToolCallUpdate":
		f.Func().Params(Id("t").Op("*").Id("ToolCallUpdate")).Id("Validate").Params().Params(Error()).Block(
			If(Id("t").Dot("ToolCallId").Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolCallId is required")))),
			Return(Nil()),
		)
		return
	}
	if def != nil && ir.PrimaryType(def) == "object" {
		if !(strings.HasSuffix(name, "Request") || strings.HasSuffix(name, "Response") || strings.HasSuffix(name, "Notification")) {
			return
		}
		f.Func().Params(Id("v").Op("*").Id(name)).Id("Validate").Params().Params(Error()).BlockFunc(func(g *Group) {
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, propName := range pkeys {
				pDef := def.Properties[propName]
				required := false
				for _, r := range def.Required {
					if r == propName {
						required = true
						break
					}
				}
				field := util.ToExportedField(propName)
				if required {
					switch ir.PrimaryType(pDef) {
					case "string":
						g.If(Id("v").Dot(field).Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					case "array":
						g.If(Id("v").Dot(field).Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					}
				}
			}
			g.Return(Nil())
		})
	}
}

// Type mapping helpers (unchanged behavior vs original)
func primitiveJenType(t string) Code {
	switch t {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	default:
		return Any()
	}
}

func jenTypeFor(d *load.Definition) Code {
	if d == nil {
		return Any()
	}
	if d.Ref != "" {
		if strings.HasPrefix(d.Ref, "#/$defs/") {
			return Id(d.Ref[len("#/$defs/"):])
		}
		return Any()
	}
	if len(d.Enum) > 0 {
		return String()
	}
	switch ir.PrimaryType(d) {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	case "array":
		return Index().Add(jenTypeFor(d.Items))
	case "object":
		if len(d.Properties) == 0 {
			return Map(String()).Any()
		}
		return Map(String()).Any()
	default:
		if len(d.AnyOf) > 0 || len(d.OneOf) > 0 {
			return Any()
		}
		return Any()
	}
}

// jenTypeForOptional maps unions that include null to pointer types where applicable.
func jenTypeForOptional(d *load.Definition) Code {
	if d == nil {
		return Any()
	}
	list := d.AnyOf
	if len(list) == 0 {
		list = d.OneOf
	}
	if len(list) == 2 {
		var nonNull *load.Definition
		for _, e := range list {
			if e == nil {
				continue
			}
			if s, ok := e.Type.(string); ok && s == "null" {
				continue
			}
			if e.Const != nil {
				nn := *e
				nn.Type = "string"
				nonNull = &nn
			} else {
				nonNull = e
			}
		}
		if nonNull != nil {
			if nonNull.Ref != "" && strings.HasPrefix(nonNull.Ref, "#/$defs/") {
				return Op("*").Id(nonNull.Ref[len("#/$defs/"):])
			}
			switch ir.PrimaryType(nonNull) {
			case "string":
				return Op("*").String()
			case "integer":
				return Op("*").Int()
			case "number":
				return Op("*").Float64()
			case "boolean":
				return Op("*").Bool()
			}
		}
	}
	return jenTypeFor(d)
}

// Specialized emitters copied from original (unchanged behavior).
func emitContentBlockJen(f *File) {
	f.Type().Id("ResourceLinkContent").Struct(
		Id("Annotations").Any().Tag(map[string]string{"json": "annotations,omitempty"}),
		Id("Description").Op("*").String().Tag(map[string]string{"json": "description,omitempty"}),
		Id("MimeType").Op("*").String().Tag(map[string]string{"json": "mimeType,omitempty"}),
		Id("Name").String().Tag(map[string]string{"json": "name"}),
		Id("Size").Op("*").Int64().Tag(map[string]string{"json": "size,omitempty"}),
		Id("Title").Op("*").String().Tag(map[string]string{"json": "title,omitempty"}),
		Id("Uri").String().Tag(map[string]string{"json": "uri"}),
	)
	f.Line()
	f.Type().Id("ContentBlock").Struct(
		Id("Type").String().Tag(map[string]string{"json": "type"}),
		Id("Text").Op("*").Id("TextContent").Tag(map[string]string{"json": "-"}),
		Id("Image").Op("*").Id("ImageContent").Tag(map[string]string{"json": "-"}),
		Id("Audio").Op("*").Id("AudioContent").Tag(map[string]string{"json": "-"}),
		Id("ResourceLink").Op("*").Id("ResourceLinkContent").Tag(map[string]string{"json": "-"}),
		Id("Resource").Op("*").Id("EmbeddedResource").Tag(map[string]string{"json": "-"}),
	)
	f.Line()
	f.Func().Params(Id("c").Op("*").Id("ContentBlock")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("probe").Struct(Id("Type").String().Tag(map[string]string{"json": "type"})),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("probe")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Id("c").Dot("Type").Op("=").Id("probe").Dot("Type"),
		Switch(Id("probe").Dot("Type")).Block(
			Case(Lit("text")).Block(
				Var().Id("v").Id("TextContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Text").Op("=").Op("&").Id("v"),
			),
			Case(Lit("image")).Block(
				Var().Id("v").Id("ImageContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Image").Op("=").Op("&").Id("v"),
			),
			Case(Lit("audio")).Block(
				Var().Id("v").Id("AudioContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Audio").Op("=").Op("&").Id("v"),
			),
			Case(Lit("resource_link")).Block(
				Var().Id("v").Id("ResourceLinkContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("ResourceLink").Op("=").Op("&").Id("v"),
			),
			Case(Lit("resource")).Block(
				Var().Id("v").Id("EmbeddedResource"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("c").Dot("Resource").Op("=").Op("&").Id("v"),
			),
		),
		Return(Nil()),
	)
	f.Func().Params(Id("c").Id("ContentBlock")).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).Block(
		Switch(Id("c").Dot("Type")).Block(
			Case(Lit("text")).Block(
				If(Id("c").Dot("Text").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"): Lit("text"),
						Lit("text"): Id("c").Dot("Text").Dot("Text"),
					}))),
				),
			),
			Case(Lit("image")).Block(
				If(Id("c").Dot("Image").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):     Lit("image"),
						Lit("data"):     Id("c").Dot("Image").Dot("Data"),
						Lit("mimeType"): Id("c").Dot("Image").Dot("MimeType"),
						Lit("uri"):      Id("c").Dot("Image").Dot("Uri"),
					}))),
				),
			),
			Case(Lit("audio")).Block(
				If(Id("c").Dot("Audio").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):     Lit("audio"),
						Lit("data"):     Id("c").Dot("Audio").Dot("Data"),
						Lit("mimeType"): Id("c").Dot("Audio").Dot("MimeType"),
					}))),
				),
			),
			Case(Lit("resource_link")).Block(
				If(Id("c").Dot("ResourceLink").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):        Lit("resource_link"),
						Lit("name"):        Id("c").Dot("ResourceLink").Dot("Name"),
						Lit("uri"):         Id("c").Dot("ResourceLink").Dot("Uri"),
						Lit("description"): Id("c").Dot("ResourceLink").Dot("Description"),
						Lit("mimeType"):    Id("c").Dot("ResourceLink").Dot("MimeType"),
						Lit("size"):        Id("c").Dot("ResourceLink").Dot("Size"),
						Lit("title"):       Id("c").Dot("ResourceLink").Dot("Title"),
					}))),
				),
			),
			Case(Lit("resource")).Block(
				If(Id("c").Dot("Resource").Op("!=").Nil()).Block(
					Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
						Lit("type"):     Lit("resource"),
						Lit("resource"): Id("c").Dot("Resource").Dot("Resource"),
					}))),
				),
			),
		),
		Return(Index().Byte().Values(), Nil()),
	)
	f.Line()
}

func emitToolCallContentJen(f *File) {
	f.Type().Id("DiffContent").Struct(
		Id("NewText").String().Tag(map[string]string{"json": "newText"}),
		Id("OldText").Op("*").String().Tag(map[string]string{"json": "oldText,omitempty"}),
		Id("Path").String().Tag(map[string]string{"json": "path"}),
	)
	f.Type().Id("TerminalRef").Struct(Id("TerminalId").String().Tag(map[string]string{"json": "terminalId"}))
	f.Line()
	f.Type().Id("ToolCallContent").Struct(
		Id("Type").String().Tag(map[string]string{"json": "type"}),
		Id("Content").Op("*").Id("ContentBlock").Tag(map[string]string{"json": "-"}),
		Id("Diff").Op("*").Id("DiffContent").Tag(map[string]string{"json": "-"}),
		Id("Terminal").Op("*").Id("TerminalRef").Tag(map[string]string{"json": "-"}),
	)
	f.Line()
	f.Func().Params(Id("t").Op("*").Id("ToolCallContent")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("probe").Struct(Id("Type").String().Tag(map[string]string{"json": "type"})),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("probe")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Id("t").Dot("Type").Op("=").Id("probe").Dot("Type"),
		Switch(Id("probe").Dot("Type")).Block(
			Case(Lit("content")).Block(
				Var().Id("v").Struct(
					Id("Type").String().Tag(map[string]string{"json": "type"}),
					Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}),
				),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("t").Dot("Content").Op("=").Op("&").Id("v").Dot("Content"),
			),
			Case(Lit("diff")).Block(
				Var().Id("v").Id("DiffContent"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("t").Dot("Diff").Op("=").Op("&").Id("v"),
			),
			Case(Lit("terminal")).Block(
				Var().Id("v").Id("TerminalRef"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("t").Dot("Terminal").Op("=").Op("&").Id("v"),
			),
		),
		Return(Nil()),
	)
	f.Line()
}

func emitEmbeddedResourceResourceJen(f *File) {
	f.Type().Id("EmbeddedResourceResource").Struct(
		Id("TextResourceContents").Op("*").Id("TextResourceContents").Tag(map[string]string{"json": "-"}),
		Id("BlobResourceContents").Op("*").Id("BlobResourceContents").Tag(map[string]string{"json": "-"}),
	)
	f.Line()
	f.Func().Params(Id("e").Op("*").Id("EmbeddedResourceResource")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage"),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit("text")), Id("ok")).Block(
			Var().Id("v").Id("TextResourceContents"),
			If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
			Id("e").Dot("TextResourceContents").Op("=").Op("&").Id("v"),
			Return(Nil()),
		),
		If(List(Id("_"), Id("ok2")).Op(":=").Id("m").Index(Lit("blob")), Id("ok2")).Block(
			Var().Id("v").Id("BlobResourceContents"),
			If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
			Id("e").Dot("BlobResourceContents").Op("=").Op("&").Id("v"),
			Return(Nil()),
		),
		Return(Nil()),
	)
	f.Line()
}

func emitRequestPermissionOutcomeJen(f *File) {
	f.Type().Id("RequestPermissionOutcomeCancelled").Struct()
	f.Type().Id("RequestPermissionOutcomeSelected").Struct(
		Id("OptionId").Id("PermissionOptionId").Tag(map[string]string{"json": "optionId"}),
	)
	f.Line()
	f.Type().Id("RequestPermissionOutcome").Struct(
		Id("Cancelled").Op("*").Id("RequestPermissionOutcomeCancelled").Tag(map[string]string{"json": "-"}),
		Id("Selected").Op("*").Id("RequestPermissionOutcomeSelected").Tag(map[string]string{"json": "-"}),
	)
	f.Func().Params(Id("o").Op("*").Id("RequestPermissionOutcome")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage"),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Var().Id("outcome").String(),
		If(List(Id("v"), Id("ok")).Op(":=").Id("m").Index(Lit("outcome")), Id("ok")).Block(
			Qual("encoding/json", "Unmarshal").Call(Id("v"), Op("&").Id("outcome")),
		),
		Switch(Id("outcome")).Block(
			Case(Lit("cancelled")).Block(
				Id("o").Dot("Cancelled").Op("=").Op("&").Id("RequestPermissionOutcomeCancelled").Values(),
				Return(Nil()),
			),
			Case(Lit("selected")).Block(
				Var().Id("v2").Id("RequestPermissionOutcomeSelected"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v2")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("o").Dot("Selected").Op("=").Op("&").Id("v2"),
				Return(Nil()),
			),
		),
		Return(Nil()),
	)
	f.Func().Params(Id("o").Id("RequestPermissionOutcome")).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).Block(
		If(Id("o").Dot("Cancelled").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{Lit("outcome"): Lit("cancelled")}))),
		),
		If(Id("o").Dot("Selected").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("optionId"): Id("o").Dot("Selected").Dot("OptionId"),
				Lit("outcome"):  Lit("selected"),
			}))),
		),
		Return(Index().Byte().Values(), Nil()),
	)
	f.Line()
}

func emitSessionUpdateJen(f *File) {
	f.Type().Id("SessionUpdateUserMessageChunk").Struct(Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}))
	f.Type().Id("SessionUpdateAgentMessageChunk").Struct(Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}))
	f.Type().Id("SessionUpdateAgentThoughtChunk").Struct(Id("Content").Id("ContentBlock").Tag(map[string]string{"json": "content"}))
	f.Type().Id("SessionUpdateToolCall").Struct(
		Id("Content").Index().Id("ToolCallContent").Tag(map[string]string{"json": "content,omitempty"}),
		Id("Kind").Id("ToolKind").Tag(map[string]string{"json": "kind,omitempty"}),
		Id("Locations").Index().Id("ToolCallLocation").Tag(map[string]string{"json": "locations,omitempty"}),
		Id("RawInput").Any().Tag(map[string]string{"json": "rawInput,omitempty"}),
		Id("RawOutput").Any().Tag(map[string]string{"json": "rawOutput,omitempty"}),
		Id("Status").Id("ToolCallStatus").Tag(map[string]string{"json": "status,omitempty"}),
		Id("Title").String().Tag(map[string]string{"json": "title"}),
		Id("ToolCallId").Id("ToolCallId").Tag(map[string]string{"json": "toolCallId"}),
	)
	f.Type().Id("SessionUpdateToolCallUpdate").Struct(
		Id("Content").Index().Id("ToolCallContent").Tag(map[string]string{"json": "content,omitempty"}),
		Id("Kind").Any().Tag(map[string]string{"json": "kind,omitempty"}),
		Id("Locations").Index().Id("ToolCallLocation").Tag(map[string]string{"json": "locations,omitempty"}),
		Id("RawInput").Any().Tag(map[string]string{"json": "rawInput,omitempty"}),
		Id("RawOutput").Any().Tag(map[string]string{"json": "rawOutput,omitempty"}),
		Id("Status").Any().Tag(map[string]string{"json": "status,omitempty"}),
		Id("Title").Op("*").String().Tag(map[string]string{"json": "title,omitempty"}),
		Id("ToolCallId").Id("ToolCallId").Tag(map[string]string{"json": "toolCallId"}),
	)
	f.Type().Id("SessionUpdatePlan").Struct(Id("Entries").Index().Id("PlanEntry").Tag(map[string]string{"json": "entries"}))
	f.Line()
	f.Type().Id("SessionUpdate").Struct(
		Id("UserMessageChunk").Op("*").Id("SessionUpdateUserMessageChunk").Tag(map[string]string{"json": "-"}),
		Id("AgentMessageChunk").Op("*").Id("SessionUpdateAgentMessageChunk").Tag(map[string]string{"json": "-"}),
		Id("AgentThoughtChunk").Op("*").Id("SessionUpdateAgentThoughtChunk").Tag(map[string]string{"json": "-"}),
		Id("ToolCall").Op("*").Id("SessionUpdateToolCall").Tag(map[string]string{"json": "-"}),
		Id("ToolCallUpdate").Op("*").Id("SessionUpdateToolCallUpdate").Tag(map[string]string{"json": "-"}),
		Id("Plan").Op("*").Id("SessionUpdatePlan").Tag(map[string]string{"json": "-"}),
	)
	f.Func().Params(Id("s").Op("*").Id("SessionUpdate")).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().Block(
		Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage"),
		If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
		Var().Id("kind").String(),
		If(List(Id("v"), Id("ok")).Op(":=").Id("m").Index(Lit("sessionUpdate")), Id("ok")).Block(
			Qual("encoding/json", "Unmarshal").Call(Id("v"), Op("&").Id("kind")),
		),
		Switch(Id("kind")).Block(
			Case(Lit("user_message_chunk")).Block(
				Var().Id("v").Id("SessionUpdateUserMessageChunk"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("UserMessageChunk").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("agent_message_chunk")).Block(
				Var().Id("v").Id("SessionUpdateAgentMessageChunk"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("AgentMessageChunk").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("agent_thought_chunk")).Block(
				Var().Id("v").Id("SessionUpdateAgentThoughtChunk"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("AgentThoughtChunk").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("tool_call")).Block(
				Var().Id("v").Id("SessionUpdateToolCall"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("ToolCall").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("tool_call_update")).Block(
				Var().Id("v").Id("SessionUpdateToolCallUpdate"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("ToolCallUpdate").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
			Case(Lit("plan")).Block(
				Var().Id("v").Id("SessionUpdatePlan"),
				If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")), Id("err").Op("!=").Nil()).Block(Return(Id("err"))),
				Id("s").Dot("Plan").Op("=").Op("&").Id("v"),
				Return(Nil()),
			),
		),
		Return(Nil()),
	)
	f.Func().Params(Id("s").Id("SessionUpdate")).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).Block(
		If(Id("s").Dot("UserMessageChunk").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("user_message_chunk"),
				Lit("content"):       Id("s").Dot("UserMessageChunk").Dot("Content"),
			}))),
		),
		If(Id("s").Dot("AgentMessageChunk").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("agent_message_chunk"),
				Lit("content"):       Id("s").Dot("AgentMessageChunk").Dot("Content"),
			}))),
		),
		If(Id("s").Dot("AgentThoughtChunk").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("agent_thought_chunk"),
				Lit("content"):       Id("s").Dot("AgentThoughtChunk").Dot("Content"),
			}))),
		),
		If(Id("s").Dot("ToolCall").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("tool_call"),
				Lit("content"):       Id("s").Dot("ToolCall").Dot("Content"),
				Lit("kind"):          Id("s").Dot("ToolCall").Dot("Kind"),
				Lit("locations"):     Id("s").Dot("ToolCall").Dot("Locations"),
				Lit("rawInput"):      Id("s").Dot("ToolCall").Dot("RawInput"),
				Lit("rawOutput"):     Id("s").Dot("ToolCall").Dot("RawOutput"),
				Lit("status"):        Id("s").Dot("ToolCall").Dot("Status"),
				Lit("title"):         Id("s").Dot("ToolCall").Dot("Title"),
				Lit("toolCallId"):    Id("s").Dot("ToolCall").Dot("ToolCallId"),
			}))),
		),
		If(Id("s").Dot("ToolCallUpdate").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("tool_call_update"),
				Lit("content"):       Id("s").Dot("ToolCallUpdate").Dot("Content"),
				Lit("kind"):          Id("s").Dot("ToolCallUpdate").Dot("Kind"),
				Lit("locations"):     Id("s").Dot("ToolCallUpdate").Dot("Locations"),
				Lit("rawInput"):      Id("s").Dot("ToolCallUpdate").Dot("RawInput"),
				Lit("rawOutput"):     Id("s").Dot("ToolCallUpdate").Dot("RawOutput"),
				Lit("status"):        Id("s").Dot("ToolCallUpdate").Dot("Status"),
				Lit("title"):         Id("s").Dot("ToolCallUpdate").Dot("Title"),
				Lit("toolCallId"):    Id("s").Dot("ToolCallUpdate").Dot("ToolCallId"),
			}))),
		),
		If(Id("s").Dot("Plan").Op("!=").Nil()).Block(
			Return(Qual("encoding/json", "Marshal").Call(Map(String()).Any().Values(Dict{
				Lit("sessionUpdate"): Lit("plan"),
				Lit("entries"):       Id("s").Dot("Plan").Dot("Entries"),
			}))),
		),
		Return(Index().Byte().Values(), Nil()),
	)
	f.Line()
}
