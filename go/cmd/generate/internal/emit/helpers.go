package emit

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/util"
)

// WriteHelpersJen emits go/helpers_gen.go with small constructor helpers
// for common union variants and a Ptr generic helper.
func WriteHelpersJen(outDir string, schema *load.Schema, _ *load.Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	// Content helpers
	f.Comment("TextBlock constructs a text content block.")
	f.Func().Id("TextBlock").Params(Id("text").String()).Id("ContentBlock").Block(
		Return(Id("ContentBlock").Values(Dict{
			Id("Text"): Op("&").Id("ContentBlockText").Values(Dict{Id("Type"): Lit("text"), Id("Text"): Id("text")}),
		})),
	)
	f.Line()

	f.Comment("ImageBlock constructs an inline image content block with base64-encoded data.")
	f.Func().Id("ImageBlock").Params(Id("data").String(), Id("mimeType").String()).Id("ContentBlock").Block(
		Return(Id("ContentBlock").Values(Dict{
			Id("Image"): Op("&").Id("ContentBlockImage").Values(Dict{Id("Type"): Lit("image"), Id("Data"): Id("data"), Id("MimeType"): Id("mimeType")}),
		})),
	)
	f.Line()

	f.Comment("AudioBlock constructs an inline audio content block with base64-encoded data.")
	f.Func().Id("AudioBlock").Params(Id("data").String(), Id("mimeType").String()).Id("ContentBlock").Block(
		Return(Id("ContentBlock").Values(Dict{
			Id("Audio"): Op("&").Id("ContentBlockAudio").Values(Dict{Id("Type"): Lit("audio"), Id("Data"): Id("data"), Id("MimeType"): Id("mimeType")}),
		})),
	)
	f.Line()

	f.Comment("ResourceLinkBlock constructs a resource_link content block with a name and URI.")
	f.Func().Id("ResourceLinkBlock").Params(Id("name").String(), Id("uri").String()).Id("ContentBlock").Block(
		Return(Id("ContentBlock").Values(Dict{
			Id("ResourceLink"): Op("&").Id("ContentBlockResourceLink").Values(Dict{Id("Type"): Lit("resource_link"), Id("Name"): Id("name"), Id("Uri"): Id("uri")}),
		})),
	)
	f.Line()

	f.Comment("ResourceBlock wraps an embedded resource as a content block.")
	f.Func().Id("ResourceBlock").Params(Id("res").Id("EmbeddedResource")).Id("ContentBlock").Block(
		Var().Id("r").Id("EmbeddedResource").Op("=").Id("res"),
		Return(Id("ContentBlock").Values(Dict{
			Id("Resource"): Op("&").Id("ContentBlockResource").Values(Dict{Id("Type"): Lit("resource"), Id("Resource"): Id("r").Dot("Resource")}),
		})),
	)
	f.Line()

	// ToolCall content helpers
	f.Comment("ToolContent wraps a content block as tool-call content.")
	f.Func().Id("ToolContent").Params(Id("block").Id("ContentBlock")).Id("ToolCallContent").Block(
		Return(Id("ToolCallContent").Values(Dict{
			Id("Content"): Op("&").Id("ToolCallContentContent").Values(Dict{Id("Content"): Id("block"), Id("Type"): Lit("content")}),
		})),
	)
	f.Line()

	f.Comment("ToolDiffContent constructs a diff tool-call content. If oldText is omitted, the field is left empty.")
	f.Func().Id("ToolDiffContent").Params(Id("path").String(), Id("newText").String(), Id("oldText").Op("...").String()).Id("ToolCallContent").Block(
		Var().Id("o").Op("*").String(),
		If(Id("len").Call(Id("oldText")).Op(">").Lit(0)).Block(
			Id("o").Op("=").Op("&").Id("oldText").Index(Lit(0)),
		),
		Return(Id("ToolCallContent").Values(Dict{
			Id("Diff"): Op("&").Id("ToolCallContentDiff").Values(Dict{Id("Path"): Id("path"), Id("NewText"): Id("newText"), Id("OldText"): Id("o"), Id("Type"): Lit("diff")}),
		})),
	)
	f.Line()

	f.Comment("ToolTerminalRef constructs a terminal reference tool-call content.")
	f.Func().Id("ToolTerminalRef").Params(Id("terminalId").String()).Id("ToolCallContent").Block(
		Return(Id("ToolCallContent").Values(Dict{
			Id("Terminal"): Op("&").Id("ToolCallContentTerminal").Values(Dict{Id("TerminalId"): Id("terminalId"), Id("Type"): Lit("terminal")}),
		})),
	)
	f.Line()

	// Generic pointer helper
	f.Comment("Ptr returns a pointer to v.")
	f.Func().Id("Ptr").Types(Id("T").Any()).Params(Id("v").Id("T")).Op("*").Id("T").Block(
		Return(Op("&").Id("v")),
	)

	// SessionUpdate helpers (friendly aliases)
	f.Line()
	f.Comment("UpdateUserMessage constructs a user_message_chunk update with the given content.")
	f.Func().Id("UpdateUserMessage").Params(Id("content").Id("ContentBlock")).Id("SessionUpdate").Block(
		Return(Id("SessionUpdate").Values(Dict{Id("UserMessageChunk"): Op("&").Id("SessionUpdateUserMessageChunk").Values(Dict{Id("Content"): Id("content")})})),
	)
	f.Comment("UpdateUserMessageText constructs a user_message_chunk update from text.")
	f.Func().Id("UpdateUserMessageText").Params(Id("text").String()).Id("SessionUpdate").Block(
		Return(Id("UpdateUserMessage").Call(Id("TextBlock").Call(Id("text")))),
	)

	f.Comment("UpdateAgentMessage constructs an agent_message_chunk update with the given content.")
	f.Func().Id("UpdateAgentMessage").Params(Id("content").Id("ContentBlock")).Id("SessionUpdate").Block(
		Return(Id("SessionUpdate").Values(Dict{Id("AgentMessageChunk"): Op("&").Id("SessionUpdateAgentMessageChunk").Values(Dict{Id("Content"): Id("content")})})),
	)
	f.Comment("UpdateAgentMessageText constructs an agent_message_chunk update from text.")
	f.Func().Id("UpdateAgentMessageText").Params(Id("text").String()).Id("SessionUpdate").Block(
		Return(Id("UpdateAgentMessage").Call(Id("TextBlock").Call(Id("text")))),
	)

	f.Comment("UpdateAgentThought constructs an agent_thought_chunk update with the given content.")
	f.Func().Id("UpdateAgentThought").Params(Id("content").Id("ContentBlock")).Id("SessionUpdate").Block(
		Return(Id("SessionUpdate").Values(Dict{Id("AgentThoughtChunk"): Op("&").Id("SessionUpdateAgentThoughtChunk").Values(Dict{Id("Content"): Id("content")})})),
	)
	f.Comment("UpdateAgentThoughtText constructs an agent_thought_chunk update from text.")
	f.Func().Id("UpdateAgentThoughtText").Params(Id("text").String()).Id("SessionUpdate").Block(
		Return(Id("UpdateAgentThought").Call(Id("TextBlock").Call(Id("text")))),
	)

	f.Comment("UpdatePlan constructs a plan update with the provided entries.")
	f.Func().Id("UpdatePlan").Params(Id("entries").Op("...").Id("PlanEntry")).Id("SessionUpdate").Block(
		Return(Id("SessionUpdate").Values(Dict{Id("Plan"): Op("&").Id("SessionUpdatePlan").Values(Dict{Id("Entries"): Id("entries")})})),
	)

	// Tool call start helpers with functional options (friendly aliases)
	f.Line()
	f.Type().Id("ToolCallStartOpt").Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall"))
	f.Comment("StartToolCall constructs a tool_call update with required fields and applies optional modifiers.")
	f.Func().Id("StartToolCall").Params(Id("id").Id("ToolCallId"), Id("title").String(), Id("opts").Op("...").Id("ToolCallStartOpt")).Id("SessionUpdate").Block(
		Id("tc").Op(":=").Id("SessionUpdateToolCall").Values(Dict{Id("ToolCallId"): Id("id"), Id("Title"): Id("title")}),
		For(List(Id("_"), Id("opt")).Op(":=").Range().Id("opts")).Block(Id("opt").Call(Op("&").Id("tc"))),
		Return(Id("SessionUpdate").Values(Dict{Id("ToolCall"): Op("&").Id("tc")})),
	)
	f.Comment("WithStartKind sets the kind for a tool_call start update.")
	f.Func().Id("WithStartKind").Params(Id("k").Id("ToolKind")).Id("ToolCallStartOpt").Block(
		Return(Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall")).Block(Id("tc").Dot("Kind").Op("=").Id("k"))),
	)
	f.Comment("WithStartStatus sets the status for a tool_call start update.")
	f.Func().Id("WithStartStatus").Params(Id("s").Id("ToolCallStatus")).Id("ToolCallStartOpt").Block(
		Return(Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall")).Block(Id("tc").Dot("Status").Op("=").Id("s"))),
	)
	f.Comment("WithStartContent sets the initial content for a tool_call start update.")
	f.Func().Id("WithStartContent").Params(Id("c").Index().Id("ToolCallContent")).Id("ToolCallStartOpt").Block(
		Return(Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall")).Block(Id("tc").Dot("Content").Op("=").Id("c"))),
	)
	f.Comment("WithStartLocations sets file locations and, if a single path is provided and rawInput is empty, mirrors it as rawInput.path.")
	f.Func().Id("WithStartLocations").Params(Id("l").Index().Id("ToolCallLocation")).Id("ToolCallStartOpt").Block(
		Return(Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall")).BlockFunc(func(g *Group) {
			g.Id("tc").Dot("Locations").Op("=").Id("l")
			g.If(Id("len").Call(Id("l")).Op("==").Lit(1).Op("&&").Id("l").Index(Lit(0)).Dot("Path").Op("!=").Lit("")).BlockFunc(func(h *Group) {
				// initialize rawInput if nil
				h.If(Id("tc").Dot("RawInput").Op("==").Nil()).Block(
					Id("tc").Dot("RawInput").Op("=").Map(String()).Any().Values(Dict{Lit("path"): Id("l").Index(Lit(0)).Dot("Path")}),
				).Else().BlockFunc(func(b *Group) {
					b.List(Id("m"), Id("ok")).Op(":=").Id("tc").Dot("RawInput").Assert(Map(String()).Any())
					b.If(Id("ok")).Block(
						If(List(Id("_"), Id("exists")).Op(":=").Id("m").Index(Lit("path")), Op("!").Id("exists")).Block(
							Id("m").Index(Lit("path")).Op("=").Id("l").Index(Lit(0)).Dot("Path"),
						),
					)
				})
			})
		})),
	)
	f.Comment("WithStartRawInput sets rawInput for a tool_call start update.")
	f.Func().Id("WithStartRawInput").Params(Id("v").Any()).Id("ToolCallStartOpt").Block(
		Return(Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall")).Block(Id("tc").Dot("RawInput").Op("=").Id("v"))),
	)
	f.Comment("WithStartRawOutput sets rawOutput for a tool_call start update.")
	f.Func().Id("WithStartRawOutput").Params(Id("v").Any()).Id("ToolCallStartOpt").Block(
		Return(Func().Params(Id("tc").Op("*").Id("SessionUpdateToolCall")).Block(Id("tc").Dot("RawOutput").Op("=").Id("v"))),
	)

	// Tool call update helpers with functional options (pointer fields; friendly aliases)
	f.Line()
	f.Type().Id("ToolCallUpdateOpt").Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate"))
	f.Comment("UpdateToolCall constructs a tool_call_update with the given ID and applies optional modifiers.")
	f.Func().Id("UpdateToolCall").Params(Id("id").Id("ToolCallId"), Id("opts").Op("...").Id("ToolCallUpdateOpt")).Id("SessionUpdate").Block(
		Id("tu").Op(":=").Id("SessionUpdateToolCallUpdate").Values(Dict{Id("ToolCallId"): Id("id")}),
		For(List(Id("_"), Id("opt")).Op(":=").Range().Id("opts")).Block(Id("opt").Call(Op("&").Id("tu"))),
		Return(Id("SessionUpdate").Values(Dict{Id("ToolCallUpdate"): Op("&").Id("tu")})),
	)
	f.Comment("WithUpdateTitle sets the title for a tool_call_update.")
	f.Func().Id("WithUpdateTitle").Params(Id("t").String()).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("Title").Op("=").Id("Ptr").Call(Id("t")))),
	)
	f.Comment("WithUpdateKind sets the kind for a tool_call_update.")
	f.Func().Id("WithUpdateKind").Params(Id("k").Id("ToolKind")).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("Kind").Op("=").Id("Ptr").Call(Id("k")))),
	)
	f.Comment("WithUpdateStatus sets the status for a tool_call_update.")
	f.Func().Id("WithUpdateStatus").Params(Id("s").Id("ToolCallStatus")).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("Status").Op("=").Id("Ptr").Call(Id("s")))),
	)
	f.Comment("WithUpdateContent replaces the content collection for a tool_call_update.")
	f.Func().Id("WithUpdateContent").Params(Id("c").Index().Id("ToolCallContent")).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("Content").Op("=").Id("c"))),
	)
	f.Comment("WithUpdateLocations replaces the locations collection for a tool_call_update.")
	f.Func().Id("WithUpdateLocations").Params(Id("l").Index().Id("ToolCallLocation")).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("Locations").Op("=").Id("l"))),
	)
	f.Comment("WithUpdateRawInput sets rawInput for a tool_call_update.")
	f.Func().Id("WithUpdateRawInput").Params(Id("v").Any()).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("RawInput").Op("=").Id("v"))),
	)
	f.Comment("WithUpdateRawOutput sets rawOutput for a tool_call_update.")
	f.Func().Id("WithUpdateRawOutput").Params(Id("v").Any()).Id("ToolCallUpdateOpt").Block(
		Return(Func().Params(Id("tu").Op("*").Id("SessionUpdateToolCallUpdate")).Block(Id("tu").Dot("RawOutput").Op("=").Id("v"))),
	)

	// Schema-driven generic helpers: New<Union><Variant>(required fields only)
	// Iterate definitions deterministically
	keys := make([]string, 0, len(schema.Defs))
	for k := range schema.Defs {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, name := range keys {
		def := schema.Defs[name]
		if def == nil || def.DocsIgnore || len(def.OneOf) == 0 {
			continue
		}
		// Skip string-const unions
		if isStringConstUnion(def) {
			continue
		}
		// Build variant info similarly to types emitter
		type vinfo struct {
			fieldName string
			typeName  string
			discKey   string
			discValue string
			required  []string
			props     map[string]*load.Definition
		}
		discKey := ""
		for _, v := range def.OneOf {
			if v == nil {
				continue
			}
			for k, pd := range v.Properties {
				if pd != nil && pd.Const != nil {
					discKey = k
					break
				}
			}
			if discKey != "" {
				break
			}
		}
		variants := []vinfo{}
		for idx, v := range def.OneOf {
			if v == nil {
				continue
			}
			// compute type name per types emitter
			tname := v.Title
			if tname == "" {
				if v.Ref != "" && strings.HasPrefix(v.Ref, "#/$defs/") {
					tname = v.Ref[len("#/$defs/"):]
				} else {
					if discKey != "" {
						if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
							s := fmt.Sprint(pd.Const)
							tname = name + util.ToExportedField(s)
						}
					}
					if tname == "" {
						tname = name + fmt.Sprintf("Variant%d", idx+1)
					}
				}
			}
			fieldName := tname
			dv := ""
			if discKey != "" {
				if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
					s := fmt.Sprint(pd.Const)
					fieldName = util.ToExportedField(s)
					dv = s
				}
			}
			// collect required
			req := make([]string, len(v.Required))
			copy(req, v.Required)
			variants = append(variants, vinfo{fieldName: fieldName, typeName: tname, discKey: discKey, discValue: dv, required: req, props: v.Properties})
		}
		// Emit helper per variant: func New<Union><FieldName>(...) <Union>
		for _, vi := range variants {
			// params: all required props except const discriminator
			params := []Code{}
			assigns := Dict{}
			for _, rk := range vi.required {
				if rk == vi.discKey {
					continue
				}
				pd := vi.props[rk]
				if pd == nil {
					continue
				}
				// build param using lower-cased name
				pname := rk
				// field id for struct literal
				field := util.ToExportedField(rk)
				params = append(params, Id(pname).Add(jenTypeFor(pd)))
				assigns[Id(field)] = Id(pname)
			}
			// include const discriminant if present and field exists on struct
			if vi.discKey != "" && vi.discValue != "" {
				assigns[Id(util.ToExportedField(vi.discKey))] = Lit(vi.discValue)
			}
			// Construct variant literal and wrap
			f.Comment(fmt.Sprintf("New%s%s constructs a %s using the '%s' variant.", name, vi.fieldName, name, vi.discValue))
			f.Func().Id("New" + name + vi.fieldName).Params(params...).Id(name).Block(
				Return(
					Id(name).Values(Dict{
						Id(vi.fieldName): Op("&").Id(vi.typeName).Values(assigns),
					}),
				),
			)
			f.Line()
		}
	}

	// Friendly aliases: opinionated tool call starters for common cases
	// StartReadToolCall: sets kind=read, status=pending, locations=[{path}], rawInput={path}
	f.Comment("StartReadToolCall constructs a 'tool_call' update for reading a file: kind=read, status=pending, locations=[{path}], rawInput={path}.")
	f.Func().Id("StartReadToolCall").Params(
		Id("id").Id("ToolCallId"),
		Id("title").String(),
		Id("path").String(),
		Id("opts").Op("...").Id("ToolCallStartOpt"),
	).Id("SessionUpdate").Block(
		Id("base").Op(":=").Index().Id("ToolCallStartOpt").Values(
			Id("WithStartKind").Call(Id("ToolKindRead")),
			Id("WithStartStatus").Call(Id("ToolCallStatusPending")),
			Id("WithStartLocations").Call(
				Index().Id("ToolCallLocation").Values(
					Id("ToolCallLocation").Values(Dict{Id("Path"): Id("path")}),
				),
			),
			Id("WithStartRawInput").Call(Map(String()).Any().Values(Dict{Lit("path"): Id("path")})),
		),
		Id("args").Op(":=").Id("append").Call(Id("base"), Id("opts").Op("...")),
		Return(Id("StartToolCall").Call(Id("id"), Id("title"), Id("args").Op("..."))),
	)
	f.Line()
	// StartEditToolCall: sets kind=edit, status=pending, locations=[{path}], rawInput={path, content}
	f.Comment("StartEditToolCall constructs a 'tool_call' update for editing content: kind=edit, status=pending, locations=[{path}], rawInput={path, content}.")
	f.Func().Id("StartEditToolCall").Params(
		Id("id").Id("ToolCallId"),
		Id("title").String(),
		Id("path").String(),
		Id("content").Any(),
		Id("opts").Op("...").Id("ToolCallStartOpt"),
	).Id("SessionUpdate").Block(
		Id("base").Op(":=").Index().Id("ToolCallStartOpt").Values(
			Id("WithStartKind").Call(Id("ToolKindEdit")),
			Id("WithStartStatus").Call(Id("ToolCallStatusPending")),
			Id("WithStartLocations").Call(
				Index().Id("ToolCallLocation").Values(
					Id("ToolCallLocation").Values(Dict{Id("Path"): Id("path")}),
				),
			),
			Id("WithStartRawInput").Call(Map(String()).Any().Values(Dict{Lit("path"): Id("path"), Lit("content"): Id("content")})),
		),
		Id("args").Op(":=").Id("append").Call(Id("base"), Id("opts").Op("...")),
		Return(Id("StartToolCall").Call(Id("id"), Id("title"), Id("args").Op("..."))),
	)
	f.Line()

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "helpers_gen.go"), buf.Bytes(), 0o644)
}

// Note: isStringConstUnion exists in types emitter; we reference that file-level function
