// Code generated by acp-go-generator; DO NOT EDIT.

package acp

import (
	"context"
	"encoding/json"
	"fmt"
)

// Capabilities supported by the agent.  Advertised during initialization to inform the client about available features and content types.  See protocol docs: [Agent Capabilities](https://agentclientprotocol.com/protocol/initialization#agent-capabilities)
type AgentCapabilities struct {
	// Whether the agent supports 'session/load'.
	LoadSession bool `json:"loadSession,omitempty"`
	// Prompt capabilities supported by the agent.
	PromptCapabilities PromptCapabilities `json:"promptCapabilities,omitempty"`
}

// All possible notifications that an agent can send to a client.  This enum is used internally for routing RPC notifications. You typically won't need to use this directly - use the notification methods on the ['Client'] trait instead.  Notifications do not expect a response.
// AgentNotification is a union or complex schema; represented generically.
type AgentNotification any

// All possible requests that an agent can send to a client.  This enum is used internally for routing RPC requests. You typically won't need to use this directly - instead, use the methods on the ['Client'] trait.  This enum encompasses all method calls from agent to client.
// AgentRequest is a union or complex schema; represented generically.
type AgentRequest any

// All possible responses that an agent can send to a client.  This enum is used internally for routing RPC responses. You typically won't need to use this directly - the responses are handled automatically by the connection.  These are responses to the corresponding ClientRequest variants.
// AgentResponse is a union or complex schema; represented generically.
type AgentResponse any

// Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
type Annotations struct {
	Audience     []Role   `json:"audience,omitempty"`
	LastModified *string  `json:"lastModified,omitempty"`
	Priority     *float64 `json:"priority,omitempty"`
}

// Audio provided to or from an LLM.
type AudioContent struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
}

// Describes an available authentication method.
type AuthMethod struct {
	// Optional description providing more details about this authentication method.
	Description *string `json:"description,omitempty"`
	// Unique identifier for this authentication method.
	Id AuthMethodId `json:"id"`
	// Human-readable name of the authentication method.
	Name string `json:"name"`
}

// Unique identifier for an authentication method.
type AuthMethodId string

// Request parameters for the authenticate method.  Specifies which authentication method to use.
type AuthenticateRequest struct {
	// The ID of the authentication method to use. Must be one of the methods advertised in the initialize response.
	MethodId AuthMethodId `json:"methodId"`
}

func (v *AuthenticateRequest) Validate() error {
	return nil
}

// Information about a command.
type AvailableCommand struct {
	// Human-readable description of what the command does.
	Description string `json:"description"`
	// Input for the command if required
	Input *AvailableCommandInput `json:"input,omitempty"`
	// Command name (e.g., "create_plan", "research_codebase").
	Name string `json:"name"`
}

// All text that was typed after the command name is provided as input.
type UnstructuredCommandInput struct {
	// A brief description of the expected input
	Hint string `json:"hint"`
}

type AvailableCommandInput struct {
	UnstructuredCommandInput *UnstructuredCommandInput `json:"-"`
}

func (u *AvailableCommandInput) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v UnstructuredCommandInput
		var match bool = true
		if _, ok := m["hint"]; !ok {
			match = false
		}
		if match {
			if err := json.Unmarshal(b, &v); err != nil {
				return err
			}
			u.UnstructuredCommandInput = &v
			return nil
		}
	}
	{
		var v UnstructuredCommandInput
		if err := json.Unmarshal(b, &v); err == nil {
			u.UnstructuredCommandInput = &v
			return nil
		}
	}
	return nil
}
func (u AvailableCommandInput) MarshalJSON() ([]byte, error) {
	if u.UnstructuredCommandInput != nil {
		return json.Marshal(*u.UnstructuredCommandInput)
	}
	return []byte{}, nil
}

// Binary resource contents.
type BlobResourceContents struct {
	Blob     string  `json:"blob"`
	MimeType *string `json:"mimeType,omitempty"`
	Uri      string  `json:"uri"`
}

// Notification to cancel ongoing operations for a session.  See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type CancelNotification struct {
	// The ID of the session to cancel operations for.
	SessionId SessionId `json:"sessionId"`
}

func (v *CancelNotification) Validate() error {
	return nil
}

// Capabilities supported by the client.  Advertised during initialization to inform the agent about available features and methods.  See protocol docs: [Client Capabilities](https://agentclientprotocol.com/protocol/initialization#client-capabilities)
type ClientCapabilities struct {
	// File system capabilities supported by the client. Determines which file operations the agent can request.
	Fs FileSystemCapability `json:"fs,omitempty"`
	// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.
	Terminal bool `json:"terminal,omitempty"`
}

// All possible notifications that a client can send to an agent.  This enum is used internally for routing RPC notifications. You typically won't need to use this directly - use the notification methods on the ['Agent'] trait instead.  Notifications do not expect a response.
// ClientNotification is a union or complex schema; represented generically.
type ClientNotification any

// All possible requests that a client can send to an agent.  This enum is used internally for routing RPC requests. You typically won't need to use this directly - instead, use the methods on the ['Agent'] trait.  This enum encompasses all method calls from client to agent.
// ClientRequest is a union or complex schema; represented generically.
type ClientRequest any

// All possible responses that a client can send to an agent.  This enum is used internally for routing RPC responses. You typically won't need to use this directly - the responses are handled automatically by the connection.  These are responses to the corresponding AgentRequest variants.
// ClientResponse is a union or complex schema; represented generically.
type ClientResponse any

// Content blocks represent displayable information in the Agent Client Protocol.  They provide a structured way to handle various types of user-facing content—whether it's text from language models, images for analysis, or embedded resources for context.  Content blocks appear in: - User prompts sent via 'session/prompt' - Language model output streamed through 'session/update' notifications - Progress updates and results from tool calls  This structure is compatible with the Model Context Protocol (MCP), enabling agents to seamlessly forward content from MCP tool outputs without transformation.  See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
type ResourceLinkContent struct {
	Annotations any     `json:"annotations,omitempty"`
	Description *string `json:"description,omitempty"`
	MimeType    *string `json:"mimeType,omitempty"`
	Name        string  `json:"name"`
	Size        *int64  `json:"size,omitempty"`
	Title       *string `json:"title,omitempty"`
	Uri         string  `json:"uri"`
}

type ContentBlock struct {
	Type         string               `json:"type"`
	Text         *TextContent         `json:"-"`
	Image        *ImageContent        `json:"-"`
	Audio        *AudioContent        `json:"-"`
	ResourceLink *ResourceLinkContent `json:"-"`
	Resource     *EmbeddedResource    `json:"-"`
}

func (c *ContentBlock) UnmarshalJSON(b []byte) error {
	var probe struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(b, &probe); err != nil {
		return err
	}
	c.Type = probe.Type
	switch probe.Type {
	case "text":
		var v TextContent
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		c.Text = &v
	case "image":
		var v ImageContent
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		c.Image = &v
	case "audio":
		var v AudioContent
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		c.Audio = &v
	case "resource_link":
		var v ResourceLinkContent
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		c.ResourceLink = &v
	case "resource":
		var v EmbeddedResource
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		c.Resource = &v
	}
	return nil
}
func (c ContentBlock) MarshalJSON() ([]byte, error) {
	switch c.Type {
	case "text":
		if c.Text != nil {
			return json.Marshal(map[string]any{
				"text": c.Text.Text,
				"type": "text",
			})
		}
	case "image":
		if c.Image != nil {
			return json.Marshal(map[string]any{
				"data":     c.Image.Data,
				"mimeType": c.Image.MimeType,
				"type":     "image",
				"uri":      c.Image.Uri,
			})
		}
	case "audio":
		if c.Audio != nil {
			return json.Marshal(map[string]any{
				"data":     c.Audio.Data,
				"mimeType": c.Audio.MimeType,
				"type":     "audio",
			})
		}
	case "resource_link":
		if c.ResourceLink != nil {
			return json.Marshal(map[string]any{
				"description": c.ResourceLink.Description,
				"mimeType":    c.ResourceLink.MimeType,
				"name":        c.ResourceLink.Name,
				"size":        c.ResourceLink.Size,
				"title":       c.ResourceLink.Title,
				"type":        "resource_link",
				"uri":         c.ResourceLink.Uri,
			})
		}
	case "resource":
		if c.Resource != nil {
			return json.Marshal(map[string]any{
				"resource": c.Resource.Resource,
				"type":     "resource",
			})
		}
	}
	return []byte{}, nil
}

func (c *ContentBlock) Validate() error {
	switch c.Type {
	case "text":
		if c.Text == nil {
			return fmt.Errorf("contentblock.text missing")
		}
	case "image":
		if c.Image == nil {
			return fmt.Errorf("contentblock.image missing")
		}
	case "audio":
		if c.Audio == nil {
			return fmt.Errorf("contentblock.audio missing")
		}
	case "resource_link":
		if c.ResourceLink == nil {
			return fmt.Errorf("contentblock.resource_link missing")
		}
	case "resource":
		if c.Resource == nil {
			return fmt.Errorf("contentblock.resource missing")
		}
	}
	return nil
}

type CreateTerminalRequest struct {
	Args            []string      `json:"args,omitempty"`
	Command         string        `json:"command"`
	Cwd             *string       `json:"cwd,omitempty"`
	Env             []EnvVariable `json:"env,omitempty"`
	OutputByteLimit *int          `json:"outputByteLimit,omitempty"`
	SessionId       SessionId     `json:"sessionId"`
}

func (v *CreateTerminalRequest) Validate() error {
	if v.Command == "" {
		return fmt.Errorf("command is required")
	}
	return nil
}

type CreateTerminalResponse struct {
	TerminalId string `json:"terminalId"`
}

func (v *CreateTerminalResponse) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// The contents of a resource, embedded into a prompt or tool call result.
type EmbeddedResource struct {
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
}

// Resource content that can be embedded in a message.
type EmbeddedResourceResource struct {
	TextResourceContents *TextResourceContents `json:"-"`
	BlobResourceContents *BlobResourceContents `json:"-"`
}

func (u *EmbeddedResourceResource) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v TextResourceContents
		if err := json.Unmarshal(b, &v); err == nil {
			u.TextResourceContents = &v
			return nil
		}
	}
	{
		var v BlobResourceContents
		if err := json.Unmarshal(b, &v); err == nil {
			u.BlobResourceContents = &v
			return nil
		}
	}
	return nil
}
func (u EmbeddedResourceResource) MarshalJSON() ([]byte, error) {
	if u.TextResourceContents != nil {
		return json.Marshal(*u.TextResourceContents)
	}
	if u.BlobResourceContents != nil {
		return json.Marshal(*u.BlobResourceContents)
	}
	return []byte{}, nil
}

// An environment variable to set when launching an MCP server.
type EnvVariable struct {
	// The name of the environment variable.
	Name string `json:"name"`
	// The value to set for the environment variable.
	Value string `json:"value"`
}

// File system capabilities that a client may support.  See protocol docs: [FileSystem](https://agentclientprotocol.com/protocol/initialization#filesystem)
type FileSystemCapability struct {
	// Whether the Client supports 'fs/read_text_file' requests.
	ReadTextFile bool `json:"readTextFile,omitempty"`
	// Whether the Client supports 'fs/write_text_file' requests.
	WriteTextFile bool `json:"writeTextFile,omitempty"`
}

// An image provided to or from an LLM.
type ImageContent struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Uri         *string      `json:"uri,omitempty"`
}

// Request parameters for the initialize method.  Sent by the client to establish connection and negotiate capabilities.  See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeRequest struct {
	// Capabilities supported by the client.
	ClientCapabilities ClientCapabilities `json:"clientCapabilities,omitempty"`
	// The latest protocol version supported by the client.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v *InitializeRequest) Validate() error {
	return nil
}

// Response from the initialize method.  Contains the negotiated protocol version and agent capabilities.  See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeResponse struct {
	// Capabilities supported by the agent.
	AgentCapabilities AgentCapabilities `json:"agentCapabilities,omitempty"`
	// Authentication methods supported by the agent.
	AuthMethods []AuthMethod `json:"authMethods,omitempty"`
	// The protocol version the client specified if supported by the agent, or the latest protocol version supported by the agent.  The client should disconnect, if it doesn't support this version.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v *InitializeResponse) Validate() error {
	return nil
}

type KillTerminalRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *KillTerminalRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Request parameters for loading an existing session.  Only available if the agent supports the 'loadSession' capability.  See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
type LoadSessionRequest struct {
	// The working directory for this session.
	Cwd string `json:"cwd"`
	// List of MCP servers to connect to for this session.
	McpServers []McpServer `json:"mcpServers"`
	// The ID of the session to load.
	SessionId SessionId `json:"sessionId"`
}

func (v *LoadSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Configuration for connecting to an MCP (Model Context Protocol) server.  MCP servers provide tools and context that the agent can use when processing prompts.  See protocol docs: [MCP Servers](https://agentclientprotocol.com/protocol/session-setup#mcp-servers)
type McpServer struct {
	// Command-line arguments to pass to the MCP server.
	Args []string `json:"args"`
	// Path to the MCP server executable.
	Command string `json:"command"`
	// Environment variables to set when launching the MCP server.
	Env []EnvVariable `json:"env"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
}

// Request parameters for creating a new session.  See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionRequest struct {
	// The working directory for this session. Must be an absolute path.
	Cwd string `json:"cwd"`
	// List of MCP (Model Context Protocol) servers the agent should connect to.
	McpServers []McpServer `json:"mcpServers"`
}

func (v *NewSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Response from creating a new session.  See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionResponse struct {
	// **UNSTABLE**  Commands that may be executed via 'session/prompt' requests
	AvailableCommands []AvailableCommand `json:"availableCommands,omitempty"`
	// Unique identifier for the created session.  Used in all subsequent requests for this conversation.
	SessionId SessionId `json:"sessionId"`
}

func (v *NewSessionResponse) Validate() error {
	return nil
}

// An option presented to the user when requesting permission.
type PermissionOption struct {
	// Hint about the nature of this permission option.
	Kind PermissionOptionKind `json:"kind"`
	// Human-readable label to display to the user.
	Name string `json:"name"`
	// Unique identifier for this permission option.
	OptionId PermissionOptionId `json:"optionId"`
}

// Unique identifier for a permission option.
type PermissionOptionId string

// The type of permission option being presented to the user.  Helps clients choose appropriate icons and UI treatment.
type PermissionOptionKind string

const (
	PermissionOptionKindAllowOnce    PermissionOptionKind = "allow_once"
	PermissionOptionKindAllowAlways  PermissionOptionKind = "allow_always"
	PermissionOptionKindRejectOnce   PermissionOptionKind = "reject_once"
	PermissionOptionKindRejectAlways PermissionOptionKind = "reject_always"
)

// An execution plan for accomplishing complex tasks.  Plans consist of multiple entries representing individual tasks or goals. Agents report plans to clients to provide visibility into their execution strategy. Plans can evolve during execution as the agent discovers new requirements or completes tasks.  See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type Plan struct {
	// The list of tasks to be accomplished.  When updating a plan, the agent must send a complete list of all entries with their current status. The client replaces the entire plan with each update.
	Entries []PlanEntry `json:"entries"`
}

// A single entry in the execution plan.  Represents a task or goal that the assistant intends to accomplish as part of fulfilling the user's request. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntry struct {
	// Human-readable description of what this task aims to accomplish.
	Content string `json:"content"`
	// The relative importance of this task. Used to indicate which tasks are most critical to the overall goal.
	Priority PlanEntryPriority `json:"priority"`
	// Current execution status of this task.
	Status PlanEntryStatus `json:"status"`
}

// Priority levels for plan entries.  Used to indicate the relative importance or urgency of different tasks in the execution plan. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryPriority string

const (
	PlanEntryPriorityHigh   PlanEntryPriority = "high"
	PlanEntryPriorityMedium PlanEntryPriority = "medium"
	PlanEntryPriorityLow    PlanEntryPriority = "low"
)

// Status of a plan entry in the execution flow.  Tracks the lifecycle of each task from planning through completion. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryStatus string

const (
	PlanEntryStatusPending    PlanEntryStatus = "pending"
	PlanEntryStatusInProgress PlanEntryStatus = "in_progress"
	PlanEntryStatusCompleted  PlanEntryStatus = "completed"
)

// Prompt capabilities supported by the agent in 'session/prompt' requests.  Baseline agent functionality requires support for ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'] in prompt requests.  Other variants must be explicitly opted in to. Capabilities for different types of content in prompt requests.  Indicates which content types beyond the baseline (text and resource links) the agent can process.  See protocol docs: [Prompt Capabilities](https://agentclientprotocol.com/protocol/initialization#prompt-capabilities)
type PromptCapabilities struct {
	// Agent supports ['ContentBlock::Audio'].
	Audio bool `json:"audio,omitempty"`
	// Agent supports embedded context in 'session/prompt' requests.  When enabled, the Client is allowed to include ['ContentBlock::Resource'] in prompt requests for pieces of context that are referenced in the message.
	EmbeddedContext bool `json:"embeddedContext,omitempty"`
	// Agent supports ['ContentBlock::Image'].
	Image bool `json:"image,omitempty"`
}

// Request parameters for sending a user prompt to the agent.  Contains the user's message and any additional context.  See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
type PromptRequest struct {
	// The blocks of content that compose the user's message.  As a baseline, the Agent MUST support ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'], while other variants are optionally enabled via ['PromptCapabilities'].  The Client MUST adapt its interface according to ['PromptCapabilities'].  The client MAY include referenced pieces of context as either ['ContentBlock::Resource'] or ['ContentBlock::ResourceLink'].  When available, ['ContentBlock::Resource'] is preferred as it avoids extra round-trips and allows the message to include pieces of context from sources the agent may not have access to.
	Prompt []ContentBlock `json:"prompt"`
	// The ID of the session to send this user message to
	SessionId SessionId `json:"sessionId"`
}

func (v *PromptRequest) Validate() error {
	if v.Prompt == nil {
		return fmt.Errorf("prompt is required")
	}
	return nil
}

// Response from processing a user prompt.  See protocol docs: [Check for Completion](https://agentclientprotocol.com/protocol/prompt-turn#4-check-for-completion)
type PromptResponse struct {
	// Indicates why the agent stopped processing the turn.
	StopReason StopReason `json:"stopReason"`
}

func (v *PromptResponse) Validate() error {
	return nil
}

// Protocol version identifier.  This version is only bumped for breaking changes. Non-breaking changes should be introduced via capabilities.
type ProtocolVersion int

// Request to read content from a text file.  Only available if the client supports the 'fs.readTextFile' capability.
type ReadTextFileRequest struct {
	// Optional maximum number of lines to read.
	Limit *int `json:"limit,omitempty"`
	// Optional line number to start reading from (1-based).
	Line *int `json:"line,omitempty"`
	// Absolute path to the file to read.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *ReadTextFileRequest) Validate() error {
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

// Response containing the contents of a text file.
type ReadTextFileResponse struct {
	Content string `json:"content"`
}

func (v *ReadTextFileResponse) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	return nil
}

type ReleaseTerminalRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *ReleaseTerminalRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// The outcome of a permission request.
// The prompt turn was cancelled before the user responded.  When a client sends a 'session/cancel' notification to cancel an ongoing prompt turn, it MUST respond to all pending 'session/request_permission' requests with this 'Cancelled' outcome.  See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type RequestPermissionOutcomeCancelled struct {
	Outcome string `json:"outcome"`
}

// The user selected one of the provided options.
type RequestPermissionOutcomeSelected struct {
	// The ID of the option the user selected.
	OptionId PermissionOptionId `json:"optionId"`
	Outcome  string             `json:"outcome"`
}

type RequestPermissionOutcome struct {
	Cancelled *RequestPermissionOutcomeCancelled `json:"-"`
	Selected  *RequestPermissionOutcomeSelected  `json:"-"`
}

func (u *RequestPermissionOutcome) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v RequestPermissionOutcomeCancelled
		var match bool = true
		if _, ok := m["outcome"]; !ok {
			match = false
		}
		var raw json.RawMessage
		var ok bool
		raw, ok = m["outcome"]
		if !ok {
			match = false
		}
		if ok {
			var tmp any
			if err := json.Unmarshal(raw, &tmp); err != nil {
				return err
			}
			if fmt.Sprint(tmp) != fmt.Sprint("cancelled") {
				match = false
			}
		}
		if match {
			if err := json.Unmarshal(b, &v); err != nil {
				return err
			}
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		var match bool = true
		if _, ok := m["outcome"]; !ok {
			match = false
		}
		if _, ok := m["optionId"]; !ok {
			match = false
		}
		var raw json.RawMessage
		var ok bool
		raw, ok = m["outcome"]
		if !ok {
			match = false
		}
		if ok {
			var tmp any
			if err := json.Unmarshal(raw, &tmp); err != nil {
				return err
			}
			if fmt.Sprint(tmp) != fmt.Sprint("selected") {
				match = false
			}
		}
		if match {
			if err := json.Unmarshal(b, &v); err != nil {
				return err
			}
			u.Selected = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeCancelled
		if err := json.Unmarshal(b, &v); err == nil {
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		if err := json.Unmarshal(b, &v); err == nil {
			u.Selected = &v
			return nil
		}
	}
	return nil
}
func (u RequestPermissionOutcome) MarshalJSON() ([]byte, error) {
	if u.Cancelled != nil {
		return json.Marshal(*u.Cancelled)
	}
	if u.Selected != nil {
		return json.Marshal(*u.Selected)
	}
	return []byte{}, nil
}

// Request for user permission to execute a tool call.  Sent when the agent needs authorization before performing a sensitive operation.  See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
type RequestPermissionRequest struct {
	// Available permission options for the user to choose from.
	Options []PermissionOption `json:"options"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// Details about the tool call requiring permission.
	ToolCall ToolCallUpdate `json:"toolCall"`
}

func (v *RequestPermissionRequest) Validate() error {
	if v.Options == nil {
		return fmt.Errorf("options is required")
	}
	return nil
}

// Response to a permission request.
type RequestPermissionResponse struct {
	// The user's decision on the permission request.
	Outcome RequestPermissionOutcome `json:"outcome"`
}

func (v *RequestPermissionResponse) Validate() error {
	return nil
}

// A resource that the server is capable of reading, included in a prompt or tool call result.
type ResourceLink struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Description *string      `json:"description,omitempty"`
	MimeType    *string      `json:"mimeType,omitempty"`
	Name        string       `json:"name"`
	Size        *int         `json:"size,omitempty"`
	Title       *string      `json:"title,omitempty"`
	Uri         string       `json:"uri"`
}

// The sender or recipient of messages and data in a conversation.
type Role string

const (
	RoleAssistant Role = "assistant"
	RoleUser      Role = "user"
)

// A unique identifier for a conversation session between a client and agent.  Sessions maintain their own context, conversation history, and state, allowing multiple independent interactions with the same agent.  # Example  ”' use agent_client_protocol::SessionId; use std::sync::Arc;  let session_id = SessionId(Arc::from("sess_abc123def456")); ”'  See protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)
type SessionId string

// Notification containing a session update from the agent.  Used to stream real-time progress and results during prompt processing.  See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
type SessionNotification struct {
	// The ID of the session this update pertains to.
	SessionId SessionId `json:"sessionId"`
	// The actual update content.
	Update SessionUpdate `json:"update"`
}

func (v *SessionNotification) Validate() error {
	return nil
}

// Different types of updates that can be sent during session processing.  These updates provide real-time feedback about the agent's progress.  See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
type SessionUpdateUserMessageChunk struct {
	Content ContentBlock `json:"content"`
}
type SessionUpdateAgentMessageChunk struct {
	Content ContentBlock `json:"content"`
}
type SessionUpdateAgentThoughtChunk struct {
	Content ContentBlock `json:"content"`
}
type SessionUpdateToolCall struct {
	Content    []ToolCallContent  `json:"content,omitempty"`
	Kind       ToolKind           `json:"kind,omitempty"`
	Locations  []ToolCallLocation `json:"locations,omitempty"`
	RawInput   any                `json:"rawInput,omitempty"`
	RawOutput  any                `json:"rawOutput,omitempty"`
	Status     ToolCallStatus     `json:"status,omitempty"`
	Title      string             `json:"title"`
	ToolCallId ToolCallId         `json:"toolCallId"`
}
type SessionUpdateToolCallUpdate struct {
	Content    []ToolCallContent  `json:"content,omitempty"`
	Kind       any                `json:"kind,omitempty"`
	Locations  []ToolCallLocation `json:"locations,omitempty"`
	RawInput   any                `json:"rawInput,omitempty"`
	RawOutput  any                `json:"rawOutput,omitempty"`
	Status     any                `json:"status,omitempty"`
	Title      *string            `json:"title,omitempty"`
	ToolCallId ToolCallId         `json:"toolCallId"`
}
type SessionUpdatePlan struct {
	Entries []PlanEntry `json:"entries"`
}

type SessionUpdate struct {
	UserMessageChunk  *SessionUpdateUserMessageChunk  `json:"-"`
	AgentMessageChunk *SessionUpdateAgentMessageChunk `json:"-"`
	AgentThoughtChunk *SessionUpdateAgentThoughtChunk `json:"-"`
	ToolCall          *SessionUpdateToolCall          `json:"-"`
	ToolCallUpdate    *SessionUpdateToolCallUpdate    `json:"-"`
	Plan              *SessionUpdatePlan              `json:"-"`
}

func (s *SessionUpdate) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	var kind string
	if v, ok := m["sessionUpdate"]; ok {
		json.Unmarshal(v, &kind)
	}
	switch kind {
	case "user_message_chunk":
		var v SessionUpdateUserMessageChunk
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		s.UserMessageChunk = &v
		return nil
	case "agent_message_chunk":
		var v SessionUpdateAgentMessageChunk
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		s.AgentMessageChunk = &v
		return nil
	case "agent_thought_chunk":
		var v SessionUpdateAgentThoughtChunk
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		s.AgentThoughtChunk = &v
		return nil
	case "tool_call":
		var v SessionUpdateToolCall
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		s.ToolCall = &v
		return nil
	case "tool_call_update":
		var v SessionUpdateToolCallUpdate
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		s.ToolCallUpdate = &v
		return nil
	case "plan":
		var v SessionUpdatePlan
		if err := json.Unmarshal(b, &v); err != nil {
			return err
		}
		s.Plan = &v
		return nil
	}
	return nil
}
func (s SessionUpdate) MarshalJSON() ([]byte, error) {
	if s.UserMessageChunk != nil {
		return json.Marshal(map[string]any{
			"content":       s.UserMessageChunk.Content,
			"sessionUpdate": "user_message_chunk",
		})
	}
	if s.AgentMessageChunk != nil {
		return json.Marshal(map[string]any{
			"content":       s.AgentMessageChunk.Content,
			"sessionUpdate": "agent_message_chunk",
		})
	}
	if s.AgentThoughtChunk != nil {
		return json.Marshal(map[string]any{
			"content":       s.AgentThoughtChunk.Content,
			"sessionUpdate": "agent_thought_chunk",
		})
	}
	if s.ToolCall != nil {
		return json.Marshal(map[string]any{
			"content":       s.ToolCall.Content,
			"kind":          s.ToolCall.Kind,
			"locations":     s.ToolCall.Locations,
			"rawInput":      s.ToolCall.RawInput,
			"rawOutput":     s.ToolCall.RawOutput,
			"sessionUpdate": "tool_call",
			"status":        s.ToolCall.Status,
			"title":         s.ToolCall.Title,
			"toolCallId":    s.ToolCall.ToolCallId,
		})
	}
	if s.ToolCallUpdate != nil {
		return json.Marshal(map[string]any{
			"content":       s.ToolCallUpdate.Content,
			"kind":          s.ToolCallUpdate.Kind,
			"locations":     s.ToolCallUpdate.Locations,
			"rawInput":      s.ToolCallUpdate.RawInput,
			"rawOutput":     s.ToolCallUpdate.RawOutput,
			"sessionUpdate": "tool_call_update",
			"status":        s.ToolCallUpdate.Status,
			"title":         s.ToolCallUpdate.Title,
			"toolCallId":    s.ToolCallUpdate.ToolCallId,
		})
	}
	if s.Plan != nil {
		return json.Marshal(map[string]any{
			"entries":       s.Plan.Entries,
			"sessionUpdate": "plan",
		})
	}
	return []byte{}, nil
}

func (s *SessionUpdate) Validate() error {
	var count int
	if s.UserMessageChunk != nil {
		count++
	}
	if s.AgentMessageChunk != nil {
		count++
	}
	if s.AgentThoughtChunk != nil {
		count++
	}
	if s.ToolCall != nil {
		count++
	}
	if s.ToolCallUpdate != nil {
		count++
	}
	if s.Plan != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("sessionupdate must have exactly one variant set")
	}
	return nil
}

// Reasons why an agent stops processing a prompt turn.  See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
type StopReason string

const (
	StopReasonEndTurn         StopReason = "end_turn"
	StopReasonMaxTokens       StopReason = "max_tokens"
	StopReasonMaxTurnRequests StopReason = "max_turn_requests"
	StopReasonRefusal         StopReason = "refusal"
	StopReasonCancelled       StopReason = "cancelled"
)

type TerminalExitStatus struct {
	ExitCode *int    `json:"exitCode,omitempty"`
	Signal   *string `json:"signal,omitempty"`
}

type TerminalOutputRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *TerminalOutputRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

type TerminalOutputResponse struct {
	ExitStatus *TerminalExitStatus `json:"exitStatus,omitempty"`
	Output     string              `json:"output"`
	Truncated  bool                `json:"truncated"`
}

func (v *TerminalOutputResponse) Validate() error {
	if v.Output == "" {
		return fmt.Errorf("output is required")
	}
	return nil
}

// Text provided to or from an LLM.
type TextContent struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Text        string       `json:"text"`
}

// Text-based resource contents.
type TextResourceContents struct {
	MimeType *string `json:"mimeType,omitempty"`
	Text     string  `json:"text"`
	Uri      string  `json:"uri"`
}

// Represents a tool call that the language model has requested.  Tool calls are actions that the agent executes on behalf of the language model, such as reading files, executing code, or fetching data from external sources.  See protocol docs: [Tool Calls](https://agentclientprotocol.com/protocol/tool-calls)
type ToolCall struct {
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked. Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call. Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput any `json:"rawOutput,omitempty"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Content produced by a tool call.  Tool calls can produce different types of content including standard content blocks (text, images) or file diffs.  See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
// Standard content block (text, images, resources).
type ToolCallContentContent struct {
	// The actual content block.
	Content ContentBlock `json:"content"`
	Type    string       `json:"type"`
}

// File modification shown as a diff.
type ToolCallContentDiff struct {
	// The new content after modification.
	NewText string `json:"newText"`
	// The original content (None for new files).
	OldText *string `json:"oldText,omitempty"`
	// The file path being modified.
	Path string `json:"path"`
	Type string `json:"type"`
}

type ToolCallContentTerminal struct {
	TerminalId string `json:"terminalId"`
	Type       string `json:"type"`
}

type ToolCallContent struct {
	Content  *ToolCallContentContent  `json:"-"`
	Diff     *ToolCallContentDiff     `json:"-"`
	Terminal *ToolCallContentTerminal `json:"-"`
}

func (u *ToolCallContent) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v ToolCallContentContent
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		var raw json.RawMessage
		var ok bool
		raw, ok = m["type"]
		if !ok {
			match = false
		}
		if ok {
			var tmp any
			if err := json.Unmarshal(raw, &tmp); err != nil {
				return err
			}
			if fmt.Sprint(tmp) != fmt.Sprint("content") {
				match = false
			}
		}
		if match {
			if err := json.Unmarshal(b, &v); err != nil {
				return err
			}
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["path"]; !ok {
			match = false
		}
		if _, ok := m["newText"]; !ok {
			match = false
		}
		var raw json.RawMessage
		var ok bool
		raw, ok = m["type"]
		if !ok {
			match = false
		}
		if ok {
			var tmp any
			if err := json.Unmarshal(raw, &tmp); err != nil {
				return err
			}
			if fmt.Sprint(tmp) != fmt.Sprint("diff") {
				match = false
			}
		}
		if match {
			if err := json.Unmarshal(b, &v); err != nil {
				return err
			}
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["terminalId"]; !ok {
			match = false
		}
		var raw json.RawMessage
		var ok bool
		raw, ok = m["type"]
		if !ok {
			match = false
		}
		if ok {
			var tmp any
			if err := json.Unmarshal(raw, &tmp); err != nil {
				return err
			}
			if fmt.Sprint(tmp) != fmt.Sprint("terminal") {
				match = false
			}
		}
		if match {
			if err := json.Unmarshal(b, &v); err != nil {
				return err
			}
			u.Terminal = &v
			return nil
		}
	}
	{
		var v ToolCallContentContent
		if err := json.Unmarshal(b, &v); err == nil {
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		if err := json.Unmarshal(b, &v); err == nil {
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		if err := json.Unmarshal(b, &v); err == nil {
			u.Terminal = &v
			return nil
		}
	}
	return nil
}
func (u ToolCallContent) MarshalJSON() ([]byte, error) {
	if u.Content != nil {
		return json.Marshal(*u.Content)
	}
	if u.Diff != nil {
		return json.Marshal(*u.Diff)
	}
	if u.Terminal != nil {
		return json.Marshal(*u.Terminal)
	}
	return []byte{}, nil
}

// Unique identifier for a tool call within a session.
type ToolCallId string

// A file location being accessed or modified by a tool.  Enables clients to implement "follow-along" features that track which files the agent is working with in real-time.  See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
type ToolCallLocation struct {
	// Optional line number within the file.
	Line *int `json:"line,omitempty"`
	// The file path being accessed or modified.
	Path string `json:"path"`
}

// Execution status of a tool call.  Tool calls progress through different statuses during their lifecycle.  See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
type ToolCallStatus string

const (
	ToolCallStatusPending    ToolCallStatus = "pending"
	ToolCallStatusInProgress ToolCallStatus = "in_progress"
	ToolCallStatusCompleted  ToolCallStatus = "completed"
	ToolCallStatusFailed     ToolCallStatus = "failed"
)

// An update to an existing tool call.  Used to report progress and results as tools execute. All fields except the tool call ID are optional - only changed fields need to be included.  See protocol docs: [Updating](https://agentclientprotocol.com/protocol/tool-calls#updating)
type ToolCallUpdate struct {
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput any `json:"rawOutput,omitempty"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

func (t *ToolCallUpdate) Validate() error {
	if t.ToolCallId == "" {
		return fmt.Errorf("toolCallId is required")
	}
	return nil
}

// Categories of tools that can be invoked.  Tool kinds help clients choose appropriate icons and optimize how they display tool execution progress.  See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
type ToolKind string

const (
	ToolKindRead    ToolKind = "read"
	ToolKindEdit    ToolKind = "edit"
	ToolKindDelete  ToolKind = "delete"
	ToolKindMove    ToolKind = "move"
	ToolKindSearch  ToolKind = "search"
	ToolKindExecute ToolKind = "execute"
	ToolKindThink   ToolKind = "think"
	ToolKindFetch   ToolKind = "fetch"
	ToolKindOther   ToolKind = "other"
)

type WaitForTerminalExitRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *WaitForTerminalExitRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

type WaitForTerminalExitResponse struct {
	ExitCode *int    `json:"exitCode,omitempty"`
	Signal   *string `json:"signal,omitempty"`
}

func (v *WaitForTerminalExitResponse) Validate() error {
	return nil
}

// Request to write content to a text file.  Only available if the client supports the 'fs.writeTextFile' capability.
type WriteTextFileRequest struct {
	// The text content to write to the file.
	Content string `json:"content"`
	// Absolute path to the file to write.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *WriteTextFileRequest) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

type Agent interface {
	Authenticate(ctx context.Context, params AuthenticateRequest) error
	Initialize(ctx context.Context, params InitializeRequest) (InitializeResponse, error)
	Cancel(ctx context.Context, params CancelNotification) error
	NewSession(ctx context.Context, params NewSessionRequest) (NewSessionResponse, error)
	Prompt(ctx context.Context, params PromptRequest) (PromptResponse, error)
}

// AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.
type AgentLoader interface {
	LoadSession(ctx context.Context, params LoadSessionRequest) error
}
type Client interface {
	ReadTextFile(ctx context.Context, params ReadTextFileRequest) (ReadTextFileResponse, error)
	WriteTextFile(ctx context.Context, params WriteTextFileRequest) error
	RequestPermission(ctx context.Context, params RequestPermissionRequest) (RequestPermissionResponse, error)
	SessionUpdate(ctx context.Context, params SessionNotification) error
}

// ClientTerminal defines terminal-related experimental methods (x-docs-ignore). Implement and advertise 'terminal: true' to enable 'terminal/*'.
type ClientTerminal interface {
	CreateTerminal(ctx context.Context, params CreateTerminalRequest) (CreateTerminalResponse, error)
	TerminalOutput(ctx context.Context, params TerminalOutputRequest) (TerminalOutputResponse, error)
	ReleaseTerminal(ctx context.Context, params ReleaseTerminalRequest) error
	WaitForTerminalExit(ctx context.Context, params WaitForTerminalExitRequest) (WaitForTerminalExitResponse, error)
}
