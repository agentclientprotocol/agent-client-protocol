// Code generated by acp-go-generator; DO NOT EDIT.

package acp

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
)

// Capabilities supported by the agent.  Advertised during initialization to inform the client about available features and content types.  See protocol docs: [Agent Capabilities](https://agentclientprotocol.com/protocol/initialization#agent-capabilities)
type AgentCapabilities struct {
	// Whether the agent supports 'session/load'.
	LoadSession bool `json:"loadSession,omitempty"`
	// Prompt capabilities supported by the agent.
	PromptCapabilities PromptCapabilities `json:"promptCapabilities,omitempty"`
}

// All possible notifications that an agent can send to a client.  This enum is used internally for routing RPC notifications. You typically won't need to use this directly - use the notification methods on the ['Client'] trait instead.  Notifications do not expect a response.
type AgentNotification struct {
	SessionNotification *SessionNotification `json:"-"`
}

func (u *AgentNotification) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v SessionNotification
		if json.Unmarshal(b, &v) == nil {
			u.SessionNotification = &v
			return nil
		}
	}
	return nil
}
func (u AgentNotification) MarshalJSON() ([]byte, error) {
	if u.SessionNotification != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.SessionNotification)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible requests that an agent can send to a client.  This enum is used internally for routing RPC requests. You typically won't need to use this directly - instead, use the methods on the ['Client'] trait.  This enum encompasses all method calls from agent to client.
type AgentRequest struct {
	WriteTextFileRequest       *WriteTextFileRequest       `json:"-"`
	ReadTextFileRequest        *ReadTextFileRequest        `json:"-"`
	RequestPermissionRequest   *RequestPermissionRequest   `json:"-"`
	CreateTerminalRequest      *CreateTerminalRequest      `json:"-"`
	TerminalOutputRequest      *TerminalOutputRequest      `json:"-"`
	ReleaseTerminalRequest     *ReleaseTerminalRequest     `json:"-"`
	WaitForTerminalExitRequest *WaitForTerminalExitRequest `json:"-"`
	KillTerminalRequest        *KillTerminalRequest        `json:"-"`
}

func (u *AgentRequest) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v WriteTextFileRequest
		if json.Unmarshal(b, &v) == nil {
			u.WriteTextFileRequest = &v
			return nil
		}
	}
	{
		var v ReadTextFileRequest
		if json.Unmarshal(b, &v) == nil {
			u.ReadTextFileRequest = &v
			return nil
		}
	}
	{
		var v RequestPermissionRequest
		if json.Unmarshal(b, &v) == nil {
			u.RequestPermissionRequest = &v
			return nil
		}
	}
	{
		var v CreateTerminalRequest
		if json.Unmarshal(b, &v) == nil {
			u.CreateTerminalRequest = &v
			return nil
		}
	}
	{
		var v TerminalOutputRequest
		if json.Unmarshal(b, &v) == nil {
			u.TerminalOutputRequest = &v
			return nil
		}
	}
	{
		var v ReleaseTerminalRequest
		if json.Unmarshal(b, &v) == nil {
			u.ReleaseTerminalRequest = &v
			return nil
		}
	}
	{
		var v WaitForTerminalExitRequest
		if json.Unmarshal(b, &v) == nil {
			u.WaitForTerminalExitRequest = &v
			return nil
		}
	}
	{
		var v KillTerminalRequest
		if json.Unmarshal(b, &v) == nil {
			u.KillTerminalRequest = &v
			return nil
		}
	}
	return nil
}
func (u AgentRequest) MarshalJSON() ([]byte, error) {
	if u.WriteTextFileRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WriteTextFileRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReadTextFileRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReadTextFileRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.RequestPermissionRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.RequestPermissionRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.CreateTerminalRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CreateTerminalRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.TerminalOutputRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TerminalOutputRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReleaseTerminalRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReleaseTerminalRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.WaitForTerminalExitRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WaitForTerminalExitRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.KillTerminalRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.KillTerminalRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible responses that an agent can send to a client.  This enum is used internally for routing RPC responses. You typically won't need to use this directly - the responses are handled automatically by the connection.  These are responses to the corresponding ClientRequest variants.
type AuthenticateResponse struct{}

type LoadSessionResponse struct{}

type AgentResponse struct {
	InitializeResponse   *InitializeResponse   `json:"-"`
	AuthenticateResponse *AuthenticateResponse `json:"-"`
	NewSessionResponse   *NewSessionResponse   `json:"-"`
	LoadSessionResponse  *LoadSessionResponse  `json:"-"`
	PromptResponse       *PromptResponse       `json:"-"`
}

func (u *AgentResponse) UnmarshalJSON(b []byte) error {
	if string(b) == "null" {
		var v AuthenticateResponse
		u.AuthenticateResponse = &v
		return nil
	}
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v InitializeResponse
		if json.Unmarshal(b, &v) == nil {
			u.InitializeResponse = &v
			return nil
		}
	}
	{
		var v AuthenticateResponse
		if json.Unmarshal(b, &v) == nil {
			u.AuthenticateResponse = &v
			return nil
		}
	}
	{
		var v NewSessionResponse
		if json.Unmarshal(b, &v) == nil {
			u.NewSessionResponse = &v
			return nil
		}
	}
	{
		var v LoadSessionResponse
		if json.Unmarshal(b, &v) == nil {
			u.LoadSessionResponse = &v
			return nil
		}
	}
	{
		var v PromptResponse
		if json.Unmarshal(b, &v) == nil {
			u.PromptResponse = &v
			return nil
		}
	}
	return nil
}
func (u AgentResponse) MarshalJSON() ([]byte, error) {
	if u.InitializeResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InitializeResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.AuthenticateResponse != nil {
		return json.Marshal(nil)
		var m map[string]any
		_b, _e := json.Marshal(*u.AuthenticateResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.NewSessionResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.NewSessionResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.LoadSessionResponse != nil {
		return json.Marshal(nil)
		var m map[string]any
		_b, _e := json.Marshal(*u.LoadSessionResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.PromptResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.PromptResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
type Annotations struct {
	Audience     []Role   `json:"audience,omitempty"`
	LastModified *string  `json:"lastModified,omitempty"`
	Priority     *float64 `json:"priority,omitempty"`
}

// Audio provided to or from an LLM.
type AudioContent struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
}

// Describes an available authentication method.
type AuthMethod struct {
	// Optional description providing more details about this authentication method.
	Description *string `json:"description,omitempty"`
	// Unique identifier for this authentication method.
	Id AuthMethodId `json:"id"`
	// Human-readable name of the authentication method.
	Name string `json:"name"`
}

// Unique identifier for an authentication method.
type AuthMethodId string

// Request parameters for the authenticate method.  Specifies which authentication method to use.
type AuthenticateRequest struct {
	// The ID of the authentication method to use. Must be one of the methods advertised in the initialize response.
	MethodId AuthMethodId `json:"methodId"`
}

func (v *AuthenticateRequest) Validate() error {
	return nil
}

// Information about a command.
type AvailableCommand struct {
	// Human-readable description of what the command does.
	Description string `json:"description"`
	// Input for the command if required
	Input *AvailableCommandInput `json:"input,omitempty"`
	// Command name (e.g., "create_plan", "research_codebase").
	Name string `json:"name"`
}

// All text that was typed after the command name is provided as input.
type UnstructuredCommandInput struct {
	// A brief description of the expected input
	Hint string `json:"hint"`
}

type AvailableCommandInput struct {
	UnstructuredCommandInput *UnstructuredCommandInput `json:"-"`
}

func (u *AvailableCommandInput) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v UnstructuredCommandInput
		var match bool = true
		if _, ok := m["hint"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.UnstructuredCommandInput = &v
			return nil
		}
	}
	{
		var v UnstructuredCommandInput
		if json.Unmarshal(b, &v) == nil {
			u.UnstructuredCommandInput = &v
			return nil
		}
	}
	return nil
}
func (u AvailableCommandInput) MarshalJSON() ([]byte, error) {
	if u.UnstructuredCommandInput != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.UnstructuredCommandInput)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Binary resource contents.
type BlobResourceContents struct {
	Blob     string  `json:"blob"`
	MimeType *string `json:"mimeType,omitempty"`
	Uri      string  `json:"uri"`
}

// Notification to cancel ongoing operations for a session.  See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type CancelNotification struct {
	// The ID of the session to cancel operations for.
	SessionId SessionId `json:"sessionId"`
}

func (v *CancelNotification) Validate() error {
	return nil
}

// Capabilities supported by the client.  Advertised during initialization to inform the agent about available features and methods.  See protocol docs: [Client Capabilities](https://agentclientprotocol.com/protocol/initialization#client-capabilities)
type ClientCapabilities struct {
	// File system capabilities supported by the client. Determines which file operations the agent can request.
	Fs FileSystemCapability `json:"fs,omitempty"`
	// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.
	Terminal bool `json:"terminal,omitempty"`
}

// All possible notifications that a client can send to an agent.  This enum is used internally for routing RPC notifications. You typically won't need to use this directly - use the notification methods on the ['Agent'] trait instead.  Notifications do not expect a response.
type ClientNotification struct {
	CancelNotification *CancelNotification `json:"-"`
}

func (u *ClientNotification) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v CancelNotification
		if json.Unmarshal(b, &v) == nil {
			u.CancelNotification = &v
			return nil
		}
	}
	return nil
}
func (u ClientNotification) MarshalJSON() ([]byte, error) {
	if u.CancelNotification != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CancelNotification)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible requests that a client can send to an agent.  This enum is used internally for routing RPC requests. You typically won't need to use this directly - instead, use the methods on the ['Agent'] trait.  This enum encompasses all method calls from client to agent.
type ClientRequest struct {
	InitializeRequest   *InitializeRequest   `json:"-"`
	AuthenticateRequest *AuthenticateRequest `json:"-"`
	NewSessionRequest   *NewSessionRequest   `json:"-"`
	LoadSessionRequest  *LoadSessionRequest  `json:"-"`
	PromptRequest       *PromptRequest       `json:"-"`
}

func (u *ClientRequest) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v InitializeRequest
		if json.Unmarshal(b, &v) == nil {
			u.InitializeRequest = &v
			return nil
		}
	}
	{
		var v AuthenticateRequest
		if json.Unmarshal(b, &v) == nil {
			u.AuthenticateRequest = &v
			return nil
		}
	}
	{
		var v NewSessionRequest
		if json.Unmarshal(b, &v) == nil {
			u.NewSessionRequest = &v
			return nil
		}
	}
	{
		var v LoadSessionRequest
		if json.Unmarshal(b, &v) == nil {
			u.LoadSessionRequest = &v
			return nil
		}
	}
	{
		var v PromptRequest
		if json.Unmarshal(b, &v) == nil {
			u.PromptRequest = &v
			return nil
		}
	}
	return nil
}
func (u ClientRequest) MarshalJSON() ([]byte, error) {
	if u.InitializeRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InitializeRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.AuthenticateRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AuthenticateRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.NewSessionRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.NewSessionRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.LoadSessionRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.LoadSessionRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.PromptRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.PromptRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible responses that a client can send to an agent.  This enum is used internally for routing RPC responses. You typically won't need to use this directly - the responses are handled automatically by the connection.  These are responses to the corresponding AgentRequest variants.
type WriteTextFileResponse struct{}

type ReleaseTerminalResponse struct{}

type KillTerminalResponse struct{}

type ClientResponse struct {
	WriteTextFileResponse       *WriteTextFileResponse       `json:"-"`
	ReadTextFileResponse        *ReadTextFileResponse        `json:"-"`
	RequestPermissionResponse   *RequestPermissionResponse   `json:"-"`
	CreateTerminalResponse      *CreateTerminalResponse      `json:"-"`
	TerminalOutputResponse      *TerminalOutputResponse      `json:"-"`
	ReleaseTerminalResponse     *ReleaseTerminalResponse     `json:"-"`
	WaitForTerminalExitResponse *WaitForTerminalExitResponse `json:"-"`
	KillTerminalResponse        *KillTerminalResponse        `json:"-"`
}

func (u *ClientResponse) UnmarshalJSON(b []byte) error {
	if string(b) == "null" {
		var v WriteTextFileResponse
		u.WriteTextFileResponse = &v
		return nil
	}
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v WriteTextFileResponse
		if json.Unmarshal(b, &v) == nil {
			u.WriteTextFileResponse = &v
			return nil
		}
	}
	{
		var v ReadTextFileResponse
		if json.Unmarshal(b, &v) == nil {
			u.ReadTextFileResponse = &v
			return nil
		}
	}
	{
		var v RequestPermissionResponse
		if json.Unmarshal(b, &v) == nil {
			u.RequestPermissionResponse = &v
			return nil
		}
	}
	{
		var v CreateTerminalResponse
		if json.Unmarshal(b, &v) == nil {
			u.CreateTerminalResponse = &v
			return nil
		}
	}
	{
		var v TerminalOutputResponse
		if json.Unmarshal(b, &v) == nil {
			u.TerminalOutputResponse = &v
			return nil
		}
	}
	{
		var v ReleaseTerminalResponse
		if json.Unmarshal(b, &v) == nil {
			u.ReleaseTerminalResponse = &v
			return nil
		}
	}
	{
		var v WaitForTerminalExitResponse
		if json.Unmarshal(b, &v) == nil {
			u.WaitForTerminalExitResponse = &v
			return nil
		}
	}
	{
		var v KillTerminalResponse
		if json.Unmarshal(b, &v) == nil {
			u.KillTerminalResponse = &v
			return nil
		}
	}
	return nil
}
func (u ClientResponse) MarshalJSON() ([]byte, error) {
	if u.WriteTextFileResponse != nil {
		return json.Marshal(nil)
		var m map[string]any
		_b, _e := json.Marshal(*u.WriteTextFileResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReadTextFileResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReadTextFileResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.RequestPermissionResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.RequestPermissionResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.CreateTerminalResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CreateTerminalResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.TerminalOutputResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TerminalOutputResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReleaseTerminalResponse != nil {
		return json.Marshal(nil)
		var m map[string]any
		_b, _e := json.Marshal(*u.ReleaseTerminalResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.WaitForTerminalExitResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WaitForTerminalExitResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.KillTerminalResponse != nil {
		return json.Marshal(nil)
		var m map[string]any
		_b, _e := json.Marshal(*u.KillTerminalResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Content blocks represent displayable information in the Agent Client Protocol.  They provide a structured way to handle various types of user-facing content—whether it's text from language models, images for analysis, or embedded resources for context.  Content blocks appear in: - User prompts sent via 'session/prompt' - Language model output streamed through 'session/update' notifications - Progress updates and results from tool calls  This structure is compatible with the Model Context Protocol (MCP), enabling agents to seamlessly forward content from MCP tool outputs without transformation.  See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
// Plain text content  All agents MUST support text content blocks in prompts.
type ContentBlockText struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Text        string       `json:"text"`
	Type        string       `json:"type"`
}

// Images for visual context or analysis.  Requires the 'image' prompt capability when included in prompts.
type ContentBlockImage struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Type        string       `json:"type"`
	Uri         *string      `json:"uri,omitempty"`
}

// Audio data for transcription or analysis.  Requires the 'audio' prompt capability when included in prompts.
type ContentBlockAudio struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Type        string       `json:"type"`
}

// References to resources that the agent can access.  All agents MUST support resource links in prompts.
type ContentBlockResourceLink struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Description *string      `json:"description,omitempty"`
	MimeType    *string      `json:"mimeType,omitempty"`
	Name        string       `json:"name"`
	Size        *int         `json:"size,omitempty"`
	Title       *string      `json:"title,omitempty"`
	Type        string       `json:"type"`
	Uri         string       `json:"uri"`
}

// Complete resource contents embedded directly in the message.  Preferred for including context as it avoids extra round-trips.  Requires the 'embeddedContext' prompt capability when included in prompts.
type ContentBlockResource struct {
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
	Type        string                   `json:"type"`
}

type ContentBlock struct {
	Text         *ContentBlockText         `json:"-"`
	Image        *ContentBlockImage        `json:"-"`
	Audio        *ContentBlockAudio        `json:"-"`
	ResourceLink *ContentBlockResourceLink `json:"-"`
	Resource     *ContentBlockResource     `json:"-"`
}

func (u *ContentBlock) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["type"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "text":
			var v ContentBlockText
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Text = &v
			return nil
		case "image":
			var v ContentBlockImage
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Image = &v
			return nil
		case "audio":
			var v ContentBlockAudio
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Audio = &v
			return nil
		case "resource_link":
			var v ContentBlockResourceLink
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ResourceLink = &v
			return nil
		case "resource":
			var v ContentBlockResource
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Resource = &v
			return nil
		}
	}
	{
		var v ContentBlockText
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["text"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Text = &v
			return nil
		}
	}
	{
		var v ContentBlockImage
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["data"]; !ok {
			match = false
		}
		if _, ok := m["mimeType"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Image = &v
			return nil
		}
	}
	{
		var v ContentBlockAudio
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["data"]; !ok {
			match = false
		}
		if _, ok := m["mimeType"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Audio = &v
			return nil
		}
	}
	{
		var v ContentBlockResourceLink
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["name"]; !ok {
			match = false
		}
		if _, ok := m["uri"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ResourceLink = &v
			return nil
		}
	}
	{
		var v ContentBlockResource
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["resource"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Resource = &v
			return nil
		}
	}
	{
		var v ContentBlockText
		if json.Unmarshal(b, &v) == nil {
			u.Text = &v
			return nil
		}
	}
	{
		var v ContentBlockImage
		if json.Unmarshal(b, &v) == nil {
			u.Image = &v
			return nil
		}
	}
	{
		var v ContentBlockAudio
		if json.Unmarshal(b, &v) == nil {
			u.Audio = &v
			return nil
		}
	}
	{
		var v ContentBlockResourceLink
		if json.Unmarshal(b, &v) == nil {
			u.ResourceLink = &v
			return nil
		}
	}
	{
		var v ContentBlockResource
		if json.Unmarshal(b, &v) == nil {
			u.Resource = &v
			return nil
		}
	}
	return nil
}
func (u ContentBlock) MarshalJSON() ([]byte, error) {
	if u.Text != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Text)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "text"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "text"
			nm["text"] = m["text"]
			return json.Marshal(nm)
		}
	}
	if u.Image != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Image)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "image"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "image"
			nm["data"] = m["data"]
			nm["mimeType"] = m["mimeType"]
			if _v, _ok := m["uri"]; _ok {
				nm["uri"] = _v
			}
			return json.Marshal(nm)
		}
	}
	if u.Audio != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Audio)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "audio"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "audio"
			nm["data"] = m["data"]
			nm["mimeType"] = m["mimeType"]
			return json.Marshal(nm)
		}
	}
	if u.ResourceLink != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ResourceLink)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "resource_link"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "resource_link"
			nm["name"] = m["name"]
			nm["uri"] = m["uri"]
			if v1, ok1 := m["description"]; ok1 {
				nm["description"] = v1
			}
			if v2, ok2 := m["mimeType"]; ok2 {
				nm["mimeType"] = v2
			}
			if v3, ok3 := m["size"]; ok3 {
				nm["size"] = v3
			}
			if v4, ok4 := m["title"]; ok4 {
				nm["title"] = v4
			}
			return json.Marshal(nm)
		}
	}
	if u.Resource != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Resource)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "resource"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "resource"
			nm["resource"] = m["resource"]
			return json.Marshal(nm)
		}
	}
	return []byte{}, nil
}

func (u *ContentBlock) Validate() error {
	var count int
	if u.Text != nil {
		count++
	}
	if u.Image != nil {
		count++
	}
	if u.Audio != nil {
		count++
	}
	if u.ResourceLink != nil {
		count++
	}
	if u.Resource != nil {
		count++
	}
	if count != 1 {
		return errors.New("ContentBlock must have exactly one variant set")
	}
	return nil
}

type CreateTerminalRequest struct {
	Args            []string      `json:"args,omitempty"`
	Command         string        `json:"command"`
	Cwd             *string       `json:"cwd,omitempty"`
	Env             []EnvVariable `json:"env,omitempty"`
	OutputByteLimit *int          `json:"outputByteLimit,omitempty"`
	SessionId       SessionId     `json:"sessionId"`
}

func (v *CreateTerminalRequest) Validate() error {
	if v.Command == "" {
		return fmt.Errorf("command is required")
	}
	return nil
}

type CreateTerminalResponse struct {
	TerminalId string `json:"terminalId"`
}

func (v *CreateTerminalResponse) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// The contents of a resource, embedded into a prompt or tool call result.
type EmbeddedResource struct {
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
}

// Resource content that can be embedded in a message.
type EmbeddedResourceResource struct {
	TextResourceContents *TextResourceContents `json:"-"`
	BlobResourceContents *BlobResourceContents `json:"-"`
}

func (u *EmbeddedResourceResource) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	if _, ok := m["text"]; ok {
		var v TextResourceContents
		if json.Unmarshal(b, &v) != nil {
			return errors.New("invalid variant payload")
		}
		u.TextResourceContents = &v
		return nil
	}
	if _, ok := m["blob"]; ok {
		var v BlobResourceContents
		if json.Unmarshal(b, &v) != nil {
			return errors.New("invalid variant payload")
		}
		u.BlobResourceContents = &v
		return nil
	}
	{
		var v TextResourceContents
		if json.Unmarshal(b, &v) == nil {
			u.TextResourceContents = &v
			return nil
		}
	}
	{
		var v BlobResourceContents
		if json.Unmarshal(b, &v) == nil {
			u.BlobResourceContents = &v
			return nil
		}
	}
	return nil
}
func (u EmbeddedResourceResource) MarshalJSON() ([]byte, error) {
	if u.TextResourceContents != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TextResourceContents)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.BlobResourceContents != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.BlobResourceContents)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// An environment variable to set when launching an MCP server.
type EnvVariable struct {
	// The name of the environment variable.
	Name string `json:"name"`
	// The value to set for the environment variable.
	Value string `json:"value"`
}

// File system capabilities that a client may support.  See protocol docs: [FileSystem](https://agentclientprotocol.com/protocol/initialization#filesystem)
type FileSystemCapability struct {
	// Whether the Client supports 'fs/read_text_file' requests.
	ReadTextFile bool `json:"readTextFile,omitempty"`
	// Whether the Client supports 'fs/write_text_file' requests.
	WriteTextFile bool `json:"writeTextFile,omitempty"`
}

// An image provided to or from an LLM.
type ImageContent struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Uri         *string      `json:"uri,omitempty"`
}

// Request parameters for the initialize method.  Sent by the client to establish connection and negotiate capabilities.  See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeRequest struct {
	// Capabilities supported by the client.
	ClientCapabilities ClientCapabilities `json:"clientCapabilities,omitempty"`
	// The latest protocol version supported by the client.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v *InitializeRequest) Validate() error {
	return nil
}

// Response from the initialize method.  Contains the negotiated protocol version and agent capabilities.  See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeResponse struct {
	// Capabilities supported by the agent.
	AgentCapabilities AgentCapabilities `json:"agentCapabilities,omitempty"`
	// Authentication methods supported by the agent.
	AuthMethods []AuthMethod `json:"authMethods"`
	// The protocol version the client specified if supported by the agent, or the latest protocol version supported by the agent.  The client should disconnect, if it doesn't support this version.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v *InitializeResponse) Validate() error {
	return nil
}

type KillTerminalRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *KillTerminalRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Request parameters for loading an existing session.  Only available if the agent supports the 'loadSession' capability.  See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
type LoadSessionRequest struct {
	// The working directory for this session.
	Cwd string `json:"cwd"`
	// List of MCP servers to connect to for this session.
	McpServers []McpServer `json:"mcpServers"`
	// The ID of the session to load.
	SessionId SessionId `json:"sessionId"`
}

func (v *LoadSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Configuration for connecting to an MCP (Model Context Protocol) server.  MCP servers provide tools and context that the agent can use when processing prompts.  See protocol docs: [MCP Servers](https://agentclientprotocol.com/protocol/session-setup#mcp-servers)
type McpServer struct {
	// Command-line arguments to pass to the MCP server.
	Args []string `json:"args"`
	// Path to the MCP server executable.
	Command string `json:"command"`
	// Environment variables to set when launching the MCP server.
	Env []EnvVariable `json:"env"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
}

// Request parameters for creating a new session.  See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionRequest struct {
	// The working directory for this session. Must be an absolute path.
	Cwd string `json:"cwd"`
	// List of MCP (Model Context Protocol) servers the agent should connect to.
	McpServers []McpServer `json:"mcpServers"`
}

func (v *NewSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Response from creating a new session.  See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionResponse struct {
	// **UNSTABLE**  Commands that may be executed via 'session/prompt' requests
	AvailableCommands []AvailableCommand `json:"availableCommands,omitempty"`
	// Unique identifier for the created session.  Used in all subsequent requests for this conversation.
	SessionId SessionId `json:"sessionId"`
}

func (v *NewSessionResponse) Validate() error {
	return nil
}

// An option presented to the user when requesting permission.
type PermissionOption struct {
	// Hint about the nature of this permission option.
	Kind PermissionOptionKind `json:"kind"`
	// Human-readable label to display to the user.
	Name string `json:"name"`
	// Unique identifier for this permission option.
	OptionId PermissionOptionId `json:"optionId"`
}

// Unique identifier for a permission option.
type PermissionOptionId string

// The type of permission option being presented to the user.  Helps clients choose appropriate icons and UI treatment.
type PermissionOptionKind string

const (
	PermissionOptionKindAllowOnce    PermissionOptionKind = "allow_once"
	PermissionOptionKindAllowAlways  PermissionOptionKind = "allow_always"
	PermissionOptionKindRejectOnce   PermissionOptionKind = "reject_once"
	PermissionOptionKindRejectAlways PermissionOptionKind = "reject_always"
)

// An execution plan for accomplishing complex tasks.  Plans consist of multiple entries representing individual tasks or goals. Agents report plans to clients to provide visibility into their execution strategy. Plans can evolve during execution as the agent discovers new requirements or completes tasks.  See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type Plan struct {
	// The list of tasks to be accomplished.  When updating a plan, the agent must send a complete list of all entries with their current status. The client replaces the entire plan with each update.
	Entries []PlanEntry `json:"entries"`
}

// A single entry in the execution plan.  Represents a task or goal that the assistant intends to accomplish as part of fulfilling the user's request. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntry struct {
	// Human-readable description of what this task aims to accomplish.
	Content string `json:"content"`
	// The relative importance of this task. Used to indicate which tasks are most critical to the overall goal.
	Priority PlanEntryPriority `json:"priority"`
	// Current execution status of this task.
	Status PlanEntryStatus `json:"status"`
}

// Priority levels for plan entries.  Used to indicate the relative importance or urgency of different tasks in the execution plan. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryPriority string

const (
	PlanEntryPriorityHigh   PlanEntryPriority = "high"
	PlanEntryPriorityMedium PlanEntryPriority = "medium"
	PlanEntryPriorityLow    PlanEntryPriority = "low"
)

// Status of a plan entry in the execution flow.  Tracks the lifecycle of each task from planning through completion. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryStatus string

const (
	PlanEntryStatusPending    PlanEntryStatus = "pending"
	PlanEntryStatusInProgress PlanEntryStatus = "in_progress"
	PlanEntryStatusCompleted  PlanEntryStatus = "completed"
)

// Prompt capabilities supported by the agent in 'session/prompt' requests.  Baseline agent functionality requires support for ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'] in prompt requests.  Other variants must be explicitly opted in to. Capabilities for different types of content in prompt requests.  Indicates which content types beyond the baseline (text and resource links) the agent can process.  See protocol docs: [Prompt Capabilities](https://agentclientprotocol.com/protocol/initialization#prompt-capabilities)
type PromptCapabilities struct {
	// Agent supports ['ContentBlock::Audio'].
	Audio bool `json:"audio,omitempty"`
	// Agent supports embedded context in 'session/prompt' requests.  When enabled, the Client is allowed to include ['ContentBlock::Resource'] in prompt requests for pieces of context that are referenced in the message.
	EmbeddedContext bool `json:"embeddedContext,omitempty"`
	// Agent supports ['ContentBlock::Image'].
	Image bool `json:"image,omitempty"`
}

// Request parameters for sending a user prompt to the agent.  Contains the user's message and any additional context.  See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
type PromptRequest struct {
	// The blocks of content that compose the user's message.  As a baseline, the Agent MUST support ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'], while other variants are optionally enabled via ['PromptCapabilities'].  The Client MUST adapt its interface according to ['PromptCapabilities'].  The client MAY include referenced pieces of context as either ['ContentBlock::Resource'] or ['ContentBlock::ResourceLink'].  When available, ['ContentBlock::Resource'] is preferred as it avoids extra round-trips and allows the message to include pieces of context from sources the agent may not have access to.
	Prompt []ContentBlock `json:"prompt"`
	// The ID of the session to send this user message to
	SessionId SessionId `json:"sessionId"`
}

func (v *PromptRequest) Validate() error {
	if v.Prompt == nil {
		return fmt.Errorf("prompt is required")
	}
	return nil
}

// Response from processing a user prompt.  See protocol docs: [Check for Completion](https://agentclientprotocol.com/protocol/prompt-turn#4-check-for-completion)
type PromptResponse struct {
	// Indicates why the agent stopped processing the turn.
	StopReason StopReason `json:"stopReason"`
}

func (v *PromptResponse) Validate() error {
	return nil
}

// Protocol version identifier.  This version is only bumped for breaking changes. Non-breaking changes should be introduced via capabilities.
type ProtocolVersion int

// Request to read content from a text file.  Only available if the client supports the 'fs.readTextFile' capability.
type ReadTextFileRequest struct {
	// Optional maximum number of lines to read.
	Limit *int `json:"limit,omitempty"`
	// Optional line number to start reading from (1-based).
	Line *int `json:"line,omitempty"`
	// Absolute path to the file to read.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *ReadTextFileRequest) Validate() error {
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

// Response containing the contents of a text file.
type ReadTextFileResponse struct {
	Content string `json:"content"`
}

func (v *ReadTextFileResponse) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	return nil
}

type ReleaseTerminalRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *ReleaseTerminalRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// The outcome of a permission request.
// The prompt turn was cancelled before the user responded.  When a client sends a 'session/cancel' notification to cancel an ongoing prompt turn, it MUST respond to all pending 'session/request_permission' requests with this 'Cancelled' outcome.  See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type RequestPermissionOutcomeCancelled struct {
	Outcome string `json:"outcome"`
}

// The user selected one of the provided options.
type RequestPermissionOutcomeSelected struct {
	// The ID of the option the user selected.
	OptionId PermissionOptionId `json:"optionId"`
	Outcome  string             `json:"outcome"`
}

type RequestPermissionOutcome struct {
	Cancelled *RequestPermissionOutcomeCancelled `json:"-"`
	Selected  *RequestPermissionOutcomeSelected  `json:"-"`
}

func (u *RequestPermissionOutcome) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["outcome"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "cancelled":
			var v RequestPermissionOutcomeCancelled
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Cancelled = &v
			return nil
		case "selected":
			var v RequestPermissionOutcomeSelected
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Selected = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeCancelled
		var match bool = true
		if _, ok := m["outcome"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		var match bool = true
		if _, ok := m["outcome"]; !ok {
			match = false
		}
		if _, ok := m["optionId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Selected = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeCancelled
		if json.Unmarshal(b, &v) == nil {
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		if json.Unmarshal(b, &v) == nil {
			u.Selected = &v
			return nil
		}
	}
	return nil
}
func (u RequestPermissionOutcome) MarshalJSON() ([]byte, error) {
	if u.Cancelled != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Cancelled)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["outcome"] = "cancelled"
		return json.Marshal(m)
	}
	if u.Selected != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Selected)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["outcome"] = "selected"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *RequestPermissionOutcome) Validate() error {
	var count int
	if u.Cancelled != nil {
		count++
	}
	if u.Selected != nil {
		count++
	}
	if count != 1 {
		return errors.New("RequestPermissionOutcome must have exactly one variant set")
	}
	return nil
}

// Request for user permission to execute a tool call.  Sent when the agent needs authorization before performing a sensitive operation.  See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
type RequestPermissionRequest struct {
	// Available permission options for the user to choose from.
	Options []PermissionOption `json:"options"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// Details about the tool call requiring permission.
	ToolCall ToolCallUpdate `json:"toolCall"`
}

func (v *RequestPermissionRequest) Validate() error {
	if v.Options == nil {
		return fmt.Errorf("options is required")
	}
	return nil
}

// Response to a permission request.
type RequestPermissionResponse struct {
	// The user's decision on the permission request.
	Outcome RequestPermissionOutcome `json:"outcome"`
}

func (v *RequestPermissionResponse) Validate() error {
	return nil
}

// A resource that the server is capable of reading, included in a prompt or tool call result.
type ResourceLink struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Description *string      `json:"description,omitempty"`
	MimeType    *string      `json:"mimeType,omitempty"`
	Name        string       `json:"name"`
	Size        *int         `json:"size,omitempty"`
	Title       *string      `json:"title,omitempty"`
	Uri         string       `json:"uri"`
}

// The sender or recipient of messages and data in a conversation.
type Role string

const (
	RoleAssistant Role = "assistant"
	RoleUser      Role = "user"
)

// A unique identifier for a conversation session between a client and agent.  Sessions maintain their own context, conversation history, and state, allowing multiple independent interactions with the same agent.  # Example  ”' use agent_client_protocol::SessionId; use std::sync::Arc;  let session_id = SessionId(Arc::from("sess_abc123def456")); ”'  See protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)
type SessionId string

// Notification containing a session update from the agent.  Used to stream real-time progress and results during prompt processing.  See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
type SessionNotification struct {
	// The ID of the session this update pertains to.
	SessionId SessionId `json:"sessionId"`
	// The actual update content.
	Update SessionUpdate `json:"update"`
}

func (v *SessionNotification) Validate() error {
	return nil
}

// Different types of updates that can be sent during session processing.  These updates provide real-time feedback about the agent's progress.  See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
// A chunk of the user's message being streamed.
type SessionUpdateUserMessageChunk struct {
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// A chunk of the agent's response being streamed.
type SessionUpdateAgentMessageChunk struct {
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// A chunk of the agent's internal reasoning being streamed.
type SessionUpdateAgentThoughtChunk struct {
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// Notification that a new tool call has been initiated.
type SessionUpdateToolCall struct {
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked. Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call. Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput     any    `json:"rawOutput,omitempty"`
	SessionUpdate string `json:"sessionUpdate"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Update on the status or results of a tool call.
type SessionUpdateToolCallUpdate struct {
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput     any    `json:"rawOutput,omitempty"`
	SessionUpdate string `json:"sessionUpdate"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// The agent's execution plan for complex tasks. See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type SessionUpdatePlan struct {
	// The list of tasks to be accomplished.  When updating a plan, the agent must send a complete list of all entries with their current status. The client replaces the entire plan with each update.
	Entries       []PlanEntry `json:"entries"`
	SessionUpdate string      `json:"sessionUpdate"`
}

type SessionUpdate struct {
	UserMessageChunk  *SessionUpdateUserMessageChunk  `json:"-"`
	AgentMessageChunk *SessionUpdateAgentMessageChunk `json:"-"`
	AgentThoughtChunk *SessionUpdateAgentThoughtChunk `json:"-"`
	ToolCall          *SessionUpdateToolCall          `json:"-"`
	ToolCallUpdate    *SessionUpdateToolCallUpdate    `json:"-"`
	Plan              *SessionUpdatePlan              `json:"-"`
}

func (u *SessionUpdate) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["sessionUpdate"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "user_message_chunk":
			var v SessionUpdateUserMessageChunk
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.UserMessageChunk = &v
			return nil
		case "agent_message_chunk":
			var v SessionUpdateAgentMessageChunk
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentMessageChunk = &v
			return nil
		case "agent_thought_chunk":
			var v SessionUpdateAgentThoughtChunk
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentThoughtChunk = &v
			return nil
		case "tool_call":
			var v SessionUpdateToolCall
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCall = &v
			return nil
		case "tool_call_update":
			var v SessionUpdateToolCallUpdate
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCallUpdate = &v
			return nil
		case "plan":
			var v SessionUpdatePlan
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Plan = &v
			return nil
		}
	}
	{
		var v SessionUpdateUserMessageChunk
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.UserMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentMessageChunk
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentThoughtChunk
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentThoughtChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCall
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["toolCallId"]; !ok {
			match = false
		}
		if _, ok := m["title"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCall = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCallUpdate
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["toolCallId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCallUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdatePlan
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["entries"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Plan = &v
			return nil
		}
	}
	{
		var v SessionUpdateUserMessageChunk
		if json.Unmarshal(b, &v) == nil {
			u.UserMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentMessageChunk
		if json.Unmarshal(b, &v) == nil {
			u.AgentMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentThoughtChunk
		if json.Unmarshal(b, &v) == nil {
			u.AgentThoughtChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCall
		if json.Unmarshal(b, &v) == nil {
			u.ToolCall = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCallUpdate
		if json.Unmarshal(b, &v) == nil {
			u.ToolCallUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdatePlan
		if json.Unmarshal(b, &v) == nil {
			u.Plan = &v
			return nil
		}
	}
	return nil
}
func (u SessionUpdate) MarshalJSON() ([]byte, error) {
	if u.UserMessageChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.UserMessageChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "user_message_chunk"
		return json.Marshal(m)
	}
	if u.AgentMessageChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AgentMessageChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "agent_message_chunk"
		return json.Marshal(m)
	}
	if u.AgentThoughtChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AgentThoughtChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "agent_thought_chunk"
		return json.Marshal(m)
	}
	if u.ToolCall != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ToolCall)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "tool_call"
		return json.Marshal(m)
	}
	if u.ToolCallUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ToolCallUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "tool_call_update"
		return json.Marshal(m)
	}
	if u.Plan != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Plan)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "plan"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *SessionUpdate) Validate() error {
	var count int
	if u.UserMessageChunk != nil {
		count++
	}
	if u.AgentMessageChunk != nil {
		count++
	}
	if u.AgentThoughtChunk != nil {
		count++
	}
	if u.ToolCall != nil {
		count++
	}
	if u.ToolCallUpdate != nil {
		count++
	}
	if u.Plan != nil {
		count++
	}
	if count != 1 {
		return errors.New("SessionUpdate must have exactly one variant set")
	}
	return nil
}

// Reasons why an agent stops processing a prompt turn.  See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
type StopReason string

const (
	StopReasonEndTurn         StopReason = "end_turn"
	StopReasonMaxTokens       StopReason = "max_tokens"
	StopReasonMaxTurnRequests StopReason = "max_turn_requests"
	StopReasonRefusal         StopReason = "refusal"
	StopReasonCancelled       StopReason = "cancelled"
)

type TerminalExitStatus struct {
	ExitCode *int    `json:"exitCode,omitempty"`
	Signal   *string `json:"signal,omitempty"`
}

type TerminalOutputRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *TerminalOutputRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

type TerminalOutputResponse struct {
	ExitStatus *TerminalExitStatus `json:"exitStatus,omitempty"`
	Output     string              `json:"output"`
	Truncated  bool                `json:"truncated"`
}

func (v *TerminalOutputResponse) Validate() error {
	if v.Output == "" {
		return fmt.Errorf("output is required")
	}
	return nil
}

// Text provided to or from an LLM.
type TextContent struct {
	Annotations *Annotations `json:"annotations,omitempty"`
	Text        string       `json:"text"`
}

// Text-based resource contents.
type TextResourceContents struct {
	MimeType *string `json:"mimeType,omitempty"`
	Text     string  `json:"text"`
	Uri      string  `json:"uri"`
}

// Represents a tool call that the language model has requested.  Tool calls are actions that the agent executes on behalf of the language model, such as reading files, executing code, or fetching data from external sources.  See protocol docs: [Tool Calls](https://agentclientprotocol.com/protocol/tool-calls)
type ToolCall struct {
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked. Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call. Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput any `json:"rawOutput,omitempty"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Content produced by a tool call.  Tool calls can produce different types of content including standard content blocks (text, images) or file diffs.  See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
// Standard content block (text, images, resources).
type ToolCallContentContent struct {
	// The actual content block.
	Content ContentBlock `json:"content"`
	Type    string       `json:"type"`
}

// File modification shown as a diff.
type ToolCallContentDiff struct {
	// The new content after modification.
	NewText string `json:"newText"`
	// The original content (None for new files).
	OldText *string `json:"oldText,omitempty"`
	// The file path being modified.
	Path string `json:"path"`
	Type string `json:"type"`
}

type ToolCallContentTerminal struct {
	TerminalId string `json:"terminalId"`
	Type       string `json:"type"`
}

type ToolCallContent struct {
	Content  *ToolCallContentContent  `json:"-"`
	Diff     *ToolCallContentDiff     `json:"-"`
	Terminal *ToolCallContentTerminal `json:"-"`
}

func (u *ToolCallContent) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["type"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "content":
			var v ToolCallContentContent
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Content = &v
			return nil
		case "diff":
			var v ToolCallContentDiff
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Diff = &v
			return nil
		case "terminal":
			var v ToolCallContentTerminal
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Terminal = &v
			return nil
		}
	}
	{
		var v ToolCallContentContent
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["path"]; !ok {
			match = false
		}
		if _, ok := m["newText"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["terminalId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Terminal = &v
			return nil
		}
	}
	{
		var v ToolCallContentContent
		if json.Unmarshal(b, &v) == nil {
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		if json.Unmarshal(b, &v) == nil {
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		if json.Unmarshal(b, &v) == nil {
			u.Terminal = &v
			return nil
		}
	}
	return nil
}
func (u ToolCallContent) MarshalJSON() ([]byte, error) {
	if u.Content != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Content)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "content"
		return json.Marshal(m)
	}
	if u.Diff != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Diff)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "diff"
		return json.Marshal(m)
	}
	if u.Terminal != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Terminal)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "terminal"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *ToolCallContent) Validate() error {
	var count int
	if u.Content != nil {
		count++
	}
	if u.Diff != nil {
		count++
	}
	if u.Terminal != nil {
		count++
	}
	if count != 1 {
		return errors.New("ToolCallContent must have exactly one variant set")
	}
	return nil
}

// Unique identifier for a tool call within a session.
type ToolCallId string

// A file location being accessed or modified by a tool.  Enables clients to implement "follow-along" features that track which files the agent is working with in real-time.  See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
type ToolCallLocation struct {
	// Optional line number within the file.
	Line *int `json:"line,omitempty"`
	// The file path being accessed or modified.
	Path string `json:"path"`
}

// Execution status of a tool call.  Tool calls progress through different statuses during their lifecycle.  See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
type ToolCallStatus string

const (
	ToolCallStatusPending    ToolCallStatus = "pending"
	ToolCallStatusInProgress ToolCallStatus = "in_progress"
	ToolCallStatusCompleted  ToolCallStatus = "completed"
	ToolCallStatusFailed     ToolCallStatus = "failed"
)

// An update to an existing tool call.  Used to report progress and results as tools execute. All fields except the tool call ID are optional - only changed fields need to be included.  See protocol docs: [Updating](https://agentclientprotocol.com/protocol/tool-calls#updating)
type ToolCallUpdate struct {
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput any `json:"rawOutput,omitempty"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

func (t *ToolCallUpdate) Validate() error {
	if t.ToolCallId == "" {
		return fmt.Errorf("toolCallId is required")
	}
	return nil
}

// Categories of tools that can be invoked.  Tool kinds help clients choose appropriate icons and optimize how they display tool execution progress.  See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
type ToolKind string

const (
	ToolKindRead    ToolKind = "read"
	ToolKindEdit    ToolKind = "edit"
	ToolKindDelete  ToolKind = "delete"
	ToolKindMove    ToolKind = "move"
	ToolKindSearch  ToolKind = "search"
	ToolKindExecute ToolKind = "execute"
	ToolKindThink   ToolKind = "think"
	ToolKindFetch   ToolKind = "fetch"
	ToolKindOther   ToolKind = "other"
)

type WaitForTerminalExitRequest struct {
	SessionId  SessionId `json:"sessionId"`
	TerminalId string    `json:"terminalId"`
}

func (v *WaitForTerminalExitRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

type WaitForTerminalExitResponse struct {
	ExitCode *int    `json:"exitCode,omitempty"`
	Signal   *string `json:"signal,omitempty"`
}

func (v *WaitForTerminalExitResponse) Validate() error {
	return nil
}

// Request to write content to a text file.  Only available if the client supports the 'fs.writeTextFile' capability.
type WriteTextFileRequest struct {
	// The text content to write to the file.
	Content string `json:"content"`
	// Absolute path to the file to write.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *WriteTextFileRequest) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

type Agent interface {
	Authenticate(ctx context.Context, params AuthenticateRequest) error
	Initialize(ctx context.Context, params InitializeRequest) (InitializeResponse, error)
	Cancel(ctx context.Context, params CancelNotification) error
	NewSession(ctx context.Context, params NewSessionRequest) (NewSessionResponse, error)
	Prompt(ctx context.Context, params PromptRequest) (PromptResponse, error)
}

// AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.
type AgentLoader interface {
	LoadSession(ctx context.Context, params LoadSessionRequest) error
}
type Client interface {
	ReadTextFile(ctx context.Context, params ReadTextFileRequest) (ReadTextFileResponse, error)
	WriteTextFile(ctx context.Context, params WriteTextFileRequest) error
	RequestPermission(ctx context.Context, params RequestPermissionRequest) (RequestPermissionResponse, error)
	SessionUpdate(ctx context.Context, params SessionNotification) error
}

// ClientTerminal defines terminal-related experimental methods (x-docs-ignore). Implement and advertise 'terminal: true' to enable 'terminal/*'.
type ClientTerminal interface {
	CreateTerminal(ctx context.Context, params CreateTerminalRequest) (CreateTerminalResponse, error)
	TerminalOutput(ctx context.Context, params TerminalOutputRequest) (TerminalOutputResponse, error)
	ReleaseTerminal(ctx context.Context, params ReleaseTerminalRequest) error
	WaitForTerminalExit(ctx context.Context, params WaitForTerminalExitRequest) (WaitForTerminalExitResponse, error)
}
