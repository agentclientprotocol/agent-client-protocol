---
title: "Session Input Options Discovery"
---

Author(s): [@chazcb](https://github.com/chazcb)

## Elevator pitch

> What are you proposing to change?

Allow Agents to declare what input options they accept for `session/new` and `session/load` requests. This enables Clients to build dynamic configuration UIs, showing users exactly what options are available and their types.

This RFD presents three approaches to solving this problem, all using the same **restricted JSON Schema 2020-12 subset** aligned with [MCP elicitation](https://spec.modelcontextprotocol.io/specification/draft/server/elicitation/).

## Status quo

> How do things work today and what problems does this cause? Why would we change things?

1. **Agent-specific options are invisible** - Agents may want to accept additional options (like initial model, system prompt, subagents, etc.), but there's no standard way to expose these to clients.

2. **New vs Load may differ** - Creating a new session might accept different options than loading an existing one (e.g., you might set certain options only at creation time).

3. **Client UIs are static** - Without discovery, clients must either hardcode known options or provide generic key-value inputs, neither of which provides a good user experience.

## Proposed Options

There are three potential approaches to solving session input options. All use the same JSON Schema format from the [Elicitation RFD](https://github.com/agentclientprotocol/agent-client-protocol/pull/376).

### Option 1: Use In-Session Elicitation

Use the elicitation mechanism from [PR #376](https://github.com/agentclientprotocol/agent-client-protocol/pull/376) as-is. Agent sends `elicitation/create` after session creation but before meaningful work begins.

**Flow:**
1. Client calls `session/new`
2. Agent returns session ID
3. Agent sends `elicitation/create` with config schema
4. Client shows form, user fills it
5. Agent receives config, session is ready for prompts

**Pros:**
- No new protocol additions - reuses elicitation
- Consistent with MCP patterns
- Dynamic - agent can ask different questions per session

**Cons:**
- **Client cannot show config UI until session exists** - This creates awkward UX flows where clients must create a session just to discover if there are config options to show. Users may see a "New Session" button, click it, and only then be prompted for configuration.
- Session exists in "pending config" state - semantically awkward
- **Agent initialization complexity** - Agent cannot directly use config for session initialization (model selection, system prompt setup, etc.) since the session is already created. Implementations can work around this (e.g., minting IDs that are passed to underlying engines later), but this adds complexity that will deter many agent developers.

**Verdict:** This approach works for mid-session information gathering but doesn't solve the initialization use case.

---

### Option 2: Extend Elicitation for Pre-Session Use

Extend the [Elicitation RFD](https://github.com/agentclientprotocol/agent-client-protocol/pull/376) to support elicitation _during_ the `session/new` or `session/load` flow, before the session ID is returned.

**Flow:**
1. Client calls `session/new`
2. Agent sends `elicitation/create` (while `session/new` is pending)
3. Client shows form, user fills it
4. Client responds to elicitation
5. Agent uses config values, creates session, returns session ID

**Pros:**
- Reuses elicitation infrastructure
- Agent receives config before session creation - can use for initialization decisions
- Single mechanism for all elicitation needs

**Cons:**
- **Client still cannot show config UI before user clicks "New Session"** - Same UX limitation as Option 1. Client must initiate session creation before discovering what config is needed.
- **Correlation problem** - Without a session ID, client doesn't know which pending `session/new` request the elicitation belongs to. Requires protocol additions (e.g., `relatedRequestId` on elicitation) to link them.
- **Unclear lifecycle semantics** - `session/new` "hangs" waiting for user input. What are the timeout/cancellation semantics? What if user never responds?

**Verdict:** Solves the agent initialization problem from Option 1, but still has the core UX limitation. Adds protocol complexity to solve the correlation problem.

---

### Option 3: Init-Time Config Schema Declaration (Recommended)

Agent declares config schemas at initialization. Client knows what options exist before any session is created.

**Flow:**
1. Client calls `initialize`
2. Agent returns capabilities including `configSchema` for `session/new` and `session/load`
3. Client can show config UI immediately (before user clicks "New Session")
4. User configures options, clicks "New Session"
5. Client calls `session/new` with `configOptions`
6. Agent uses config, returns session ID - session immediately usable

**Pros:**
- **Client can show config UI before "New Session"** - Best UX, no waiting
- Agent receives config with the session request - can use for initialization
- Clean session lifecycle - no intermediate states
- Simple protocol addition - just schema in init response
- No correlation problems

**Cons:**
- **Separate mechanism from elicitation** - Clients must implement another way to show config UIs, distinct from elicitation (though using the same JSON Schema format). This adds implementation surface area.
- New field in `InitializeResponse` (though minimal)
- Static declaration - same options for all sessions (agent can't dynamically vary)

**Verdict:** Recommended approach. Solves the core use case with minimal protocol complexity.

## What we propose to do about it

> What are you proposing to improve the situation?

We recommend **Option 3: Init-Time Config Schema Declaration**.

Add a `configSchema` field to `InitializeResponse` that declares what options an Agent accepts for session creation and loading. Each schema is a JSON Schema object describing the expected `configOptions` for that method.

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": 1,
    "agentCapabilities": { ... },
    "agentInfo": { ... },
    "configSchema": {
      "session/new": {
        "type": "object",
        "properties": {
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Model to use for this session",
            "oneOf": [
              { "const": "claude-sonnet-4-20250514", "title": "Sonnet 4" },
              { "const": "claude-opus-4-20250514", "title": "Opus 4" },
              { "const": "claude-haiku", "title": "Haiku" }
            ],
            "default": "claude-sonnet-4-20250514"
          },
          "systemPrompt": {
            "type": "string",
            "title": "System Prompt",
            "description": "Custom system prompt to guide the agent's behavior"
          },
          "maxTokens": {
            "type": "number",
            "title": "Max Tokens",
            "description": "Maximum tokens per response",
            "default": 4096
          },
          "enableTools": {
            "type": "boolean",
            "title": "Enable Tools",
            "description": "Allow the agent to use tools",
            "default": true
          }
        }
      },
      "session/load": {
        "type": "object",
        "properties": {
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Model to use when resuming (can differ from original)",
            "oneOf": [
              { "const": "claude-sonnet-4-20250514", "title": "Sonnet 4" },
              { "const": "claude-opus-4-20250514", "title": "Opus 4" },
              { "const": "claude-haiku", "title": "Haiku" }
            ]
          }
        }
      }
    }
  }
}
```

Clients pass config options via `configOptions` on `NewSessionRequest` and `LoadSessionRequest`:

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "session/new",
  "params": {
    ...
    "configOptions": {
      "model": "claude-sonnet-4-20250514",
      "systemPrompt": "You are a helpful coding assistant.",
      "maxTokens": 4096,
      "enableTools": true
    }
  }
}
```

## Shiny future

> How will things will play out once this feature exists?

**For Clients:**

- Query `configSchema` from `InitializeResponse` to get JSON Schema for each method
- Build dynamic forms using standard JSON Schema form rendering (same as MCP elicitation)
- **Show config UI before user starts a new session** - no waiting for round-trips
- Use `title` for field labels and `description` for help text/tooltips
- For select options (using `oneOf`), display `title` to users while sending `const` value to the agent
- Pre-populate form fields with `default` values when provided
- Show different options for "New Session" vs "Load Session" flows
- Gracefully handle Agents that don't declare any `configSchema`

**For Agents:**

- Declare supported options using JSON Schema with `title`, `description`, and `default`
- Use `default` to communicate the value that will be used if the client omits the option
- MUST handle all options as optional - clients may not provide all (or any) options
- MUST use declared `default` values when options are not provided by the client
- Receive config values as part of `session/new` - can use for initialization decisions

## Implementation details and plan

> Tell me more about your implementation. What is your detailed implementation plan?

### Passing config options

Clients send config options in `configOptions` on session requests:

```json
{
  "method": "session/new",
  "params": {
    ...
    "configOptions": {
      "model": "claude-sonnet-4-20250514",
      "maxTokens": 4096,
      "enableTools": true
    }
  }
}
```

Values should match the declared types (strings, numbers, booleans - not string-encoded).

## Schema Format

Config schemas use the **restricted JSON Schema subset** defined by [MCP elicitation](https://spec.modelcontextprotocol.io/specification/draft/server/elicitation/). This allows clients to reuse their MCP form-rendering infrastructure for ACP session options.

See the MCP elicitation specification for supported types, formats, and constraints.

### TypeScript definition

```typescript
interface InitializeResponse {
  protocolVersion: number;
  agentCapabilities: AgentCapabilities;
  agentInfo: AgentInfo;
  configSchema?: {
    "session/new"?: JSONSchema;
    "session/load"?: JSONSchema;
  };
}

// This RFD adds configOptions to the existing request types
interface NewSessionRequest {
  // ... existing fields ...
  configOptions?: Record<string, unknown>;
}

interface LoadSessionRequest {
  // ... existing fields ...
  configOptions?: Record<string, unknown>;
}
```

## Frequently asked questions

> What questions have arisen over the course of authoring this document or during subsequent discussions?

### Why not just use elicitation (Option 1)?

Elicitation happens _after_ session creation. For session config, the agent needs values _before_ creating the session to make initialization decisions (model selection, system prompt setup, etc.).

Additionally, Option 3 allows clients to show config UI before the user even clicks "New Session" - better UX with no waiting.

### Why not extend elicitation for pre-session use (Option 2)?

Option 2 requires solving the correlation problem: when an elicitation request arrives during a pending `session/new`, the client needs to know which request it belongs to. This requires protocol additions (e.g., `relatedRequestId`) and adds complexity.

Option 3 avoids this entirely - config schema is declared upfront, no correlation needed.

### How does this relate to MCP elicitation?

This proposal uses the same JSON Schema subset as [MCP elicitation](https://spec.modelcontextprotocol.io/specification/draft/server/elicitation/). Clients implementing MCP elicitation can reuse their form-rendering infrastructure for ACP session options.

The key difference is **timing**: MCP elicitation is on-demand (server requests info when needed), while this proposal provides upfront discovery at initialization.

### How does this relate to Session Config Options?

| Aspect             | Input Options (this RFD)        | Runtime Options (existing RFD)         |
| ------------------ | ------------------------------- | -------------------------------------- |
| When discovered    | At initialization               | At session creation                    |
| Schema format      | JSON Schema subset              | Custom (could adopt JSON Schema later) |
| Purpose            | Set initial configuration       | Change configuration mid-session       |
| Examples           | Initial model, system prompt    | Switch modes, change model mid-session |
| Has `currentValue` | No (options declared upfront)   | Yes (reflects current state)           |
| Update method      | N/A (set once at creation)      | `session/set_config_option`            |

### Are input options required?

No. Agents MUST handle missing options gracefully. Clients MAY not support config options UI. This is purely for discoverability and better UX.

In a future protocol version, agents could use the `required` array to indicate mandatory fields, but for v1 all fields must be optional to maintain backward compatibility.

### What about protocol-defined fields like `cwd` and `mcpServers`?

The ACP protocol already defines some fields on `NewSessionRequest` and `LoadSessionRequest` (such as `cwd` and `mcpServers`). This RFD does not aim to address whether these existing protocol fields should be migrated to `configOptions` or remain as top-level fields.

For now, this proposal focuses solely on enabling agents to declare _additional_ agent-specific options beyond what the protocol already defines.

## Revision history

- 2026-02-04: Restructured to present three options; clarified relationship to Elicitation RFD; recommended Option 3 (init-time declaration)
- 2026-02-03: Adopted JSON Schema 2020-12 subset aligned with MCP elicitation; renamed `configOptions` schema to `configSchema`; added alternatives considered section
- 2026-01-27: Restructured document; renamed schema section to "Session Config Schema"; aligned with Session Config Options using `value`/`name` pattern; removed `hint` field; renamed `inputOptions` to `configOptions` with method-name keys (`session/new`, `session/load`)
- 2025-01-26: Added `hint` and `defaultValue` optional fields to schema
- 2025-01-22: Initial draft
